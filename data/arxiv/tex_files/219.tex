\section{Biconnectivity}

In this section we introduce algorithms related to biconnectivity
and 1-edge connectivity queries.
Due to the page limits, here we give an extended abstract of the results while the full version is provided in Appendix~\ref{sec:full-biconn}.

We first review the classic approach, in which the challenge arises since just the output requires $O(m)$ writes.
Then we propose a new BC (biconnected-component) labeling as output, which has size $O(n)$ and can be constructed in $O(n)$ writes.
Queries such as determining bridges,
articulation points, and biconnected components can be answered in
$O(1)$ operations (and no writes) with the \imprep{}.
Finally we show how an \implicit{}
(as generated by Algorithm~\ref{algo:genclusters}) can be integrated into
the algorithm to further reduce the writes to $O(n/\sqrt{\wcost})$.

%All algorithms discussed in this section are easily parallelizable by replacing subroutines by parallel versions.
%The basic algorithm is new and interesting even when interpreted as a sequential algorithm.
%We thus explain the algorithm as a sequential algorithm first, and  later analyze its parallelism in Section~\ref{sec:biconn-depth}.
We begin by explaining sequential algorithms that we believe to be new and interesting.
Then in Section~\ref{sec:abstract-biconn-depth} we show that these algorithms are parallelizable.
For this section, we assume the size of the \local{}
memory in our model is $O(k\log n)$.

In this section we assume that the graph is connected.
If not, we can run the connectivity algorithm and
then run the algorithm on each component.  The results for a graph
are the union of the results of each of its connected components.

\subsection{The Classic Algorithm}

The classic parallel algorithm~\cite{tarjan1985efficient} to compute
biconnected components and bridges of a connected graph is based on
the Euler-tour technique.  The algorithm starts by building a
spanning tree $T$ rooted at some arbitrary vertex. Each vertex is
labeled by $\first(v)$
and $\last(v)$, which are the ranks of $v$'s first and last appearance
on the Euler tour of $T$.
The algorithm also computes $\low(v)$ and $\high(v)$ which indicate the first and last vertex
on the Euler tour that are connected by a nontree edge to the subtree rooted
at $v$.  The $\low(\cdot)$ and $\high(\cdot)$ values
can be computed by a reduce on each vertex followed by a leaffix on
the subtrees.  The computation takes $O(\wcost{}\log n)$ \depth,
$O(m)$ work, and $O(n)$ writes on the \ourmodel\ model, by using the algorithm
and scheduling theorem in~\cite{BBFGGMS16}.  Then a tree edge is a
bridge if and only if the child's $\low$ and $\high$ is inclusively
within the range of $\first$ and $\last$ of the parent.

The standard output of biconnected components~\cite{CLRS,JaJa92}
is an array $B[\cdot]$ with size $m$, where the $i$-th element in $B$
indicates which biconnected component the $i$-th edge belongs to.
Explicitly writing-out $B$ is costly in the asymmetric setting,
especially when $m\gg n$.
We provide an alternative
\imprep{} as output that only requires $O(n)$ writes.
%It essentially constructs an auxiliary graph which is a dual of the vertices and edges of the original graph, and runs connected components on the auxiliary graph.  The cost to just construct the auxiliary graph takes $O(m)$ writes, which can be costly

%\subsection{The \imprep{}}\label{sec:imprep}
\subsection{The BC Labeling}\label{sec:abstract-imprep}

Here we describe the \defn{BC (biconnected-component) labeling},
which effectively represents biconnectivity output in $O(n)$ space.
Instead of storing all edges within each biconnected
component, the \imprep{} stores a component label for each vertex, and a vertex
for each component.  We will later show how to use this representation
along with an implicit decomposition to reduce the writes further.

\begin{definition}[\imprep{}]
  The \imprep{} of a connected graph with respect to a rooted spanning tree
  stores a \defn{vertex label}
  $l:V\backslash \{\textit{root}\}\to [C]$ where $C$ is the number of
  biconnected components in the graph, and a \defn{component head}
  $r:[C]\to V$ of each biconnected component.
\end{definition}

\begin{lemma}
  The \imprep{} of a connected graph can be computed in $O(m)$ operations
  and $O(n + m/\wcost)$ writes on the \seqmodel. Queries about bridges, articulation
  points, or biconnected components can be answered in no writes and $O(1)$ operations
  given a \imprep{} on a rooted spanning tree.
\end{lemma}

%We now describe the algorithm to generate the \imprep{} and the space bound of it, and finally explain how to query on it.
%We ignore duplicate edges in the graph since they do not affect the biconnectivity of the graph.  More specifically, when a tree edge exists, the duplicate non-tree edge is ignored.  Otherwise, only one non-tree edge is considered in the algorithm.   They do affect the checking of bridges, which will be discussed in the query section.

\myparagraph{The algorithm to compute \imprep{}} A vertex $v\in V$ (except for the root) is an articulation point iff there exists at least one child $u$ in the spanning tree that has $\first(v)\le\low(u)$ and $\high(u)\le\last(v)$, and here we name the tree edge between such a pair of vertices to be a \defn{critical edge}.  The algorithm to compute the \imprep{} simply removes all critical edges and runs graph connectivity on all remaining graph edges.
Then the algorithm described in Section~\ref{sec:cc-linear} gives a unique component label that we assign as the vertex label.
For each component, its head is the vertex that is the parent of its cluster in the spanning tree.
Each connected component and its head form a biconnected component.
%The output now is the spanning tree, the labeling of each vertex (indicating the connected/biconnected component), and the articulation point of each biconnected component.

The correctness of the algorithm can be proven by showing the
equivalence of the result of this algorithm and that of the
Tarjan-Vishkin algorithm~\cite{tarjan1985efficient}.

Since the number of biconnected components is at most $n$, the spanning
tree, vertex labels, and component heads require only linear space. Therefore,
 the space requirement of \imprep{} is $O(n)$.

\medskip
Biconnectivity and related 1-edge-connectivity queries on \imprep{} are easy, and we review them in Appendix~\ref{sec:imprep}.

\medskip
The \imprep{} gives the biconnectivity part of Theorem~\ref{thm:main-linear}, which is formally stated as Theorem~\ref{thm:biconn-linear} in Appendix~\ref{sec:full-biconn} (see Section~\ref{sec:abstract-biconn-depth} for \depth\ analysis).

\stepcounter{theorem}\stepcounter{theorem}

\hide{
It is interesting to point out that, the \imprep{} can efficiently answer queries that are non-trivial when using the standard output.
%actually answer more queries that are non-trivial by the standard output.
For example, consider the query: are two vertices in the same biconnected component?  %Namely, is there an articulated point that can disconnect any two given vertices?
With the \imprep{} we can answer the query by finding the label of the lower vertex and checking whether the higher one has the same label or is the component head of this component.  To the best of our knowledge, answering such queries on the standard representation can be hard, unless other information is also kept (e.g.\ a block-cut tree).
}
%Meanwhile, different biconnected components are only connected by articulation points.

%\subsection{The Algorithm with Sublinear Writes}
\subsection{Biconnectivity Oracle in Sublinear Writes}
\label{sec:abstract-bcc-sublinear}

Next we will show how the \implicit{} generated by Algorithm~\ref{algo:genclusters} can be integrated into the biconnectivity algorithm to further reduce writes.
In this section we show the biconnectivity part of Theorem~\ref{thm:main-sublinear} in the case of bounded-degree graphs.  
A more formal result is stated as Theorem~\ref{thm:biconn} in Appendix~\ref{sec:full-biconn}.

The overall idea of the new algorithm is to replace the vertices in the original graph with the clusters generated by Algorithm~\ref{algo:genclusters}.  We generate the \imprep{} on the \clustergraph{} (so the vertex labels are now the \defn{cluster labels}), and then show that a connected-type query can be answered using only the information on the \clustergraph{} and a constant number of associated clusters.
The cost analysis is based on the parameter $k$, and using $k=\sqrt{\wcost{}}$ gives the result in the theorem.

%For simplicity throughout the algorithm description we assume that the graph is bounded-degree.  Later we explain how to relax this restriction.

\mysubsection{The \imprep{} on the \clustergraph}
In the first step of the algorithm we generate the \imprep{} on the \clustergraph{}
with $k=\sqrt{\wcost}$.  We root this spanning tree and name it
the clusters spanning tree.
The head vertex of a cluster is chosen as the \defn{cluster root} for that cluster. (The root cluster does not have a cluster root.)
%The direct successor vertex (the head vertex) of a spanning tree edge
%is named as the \defn{cluster root} for that specific cluster.  (The root cluster does not have a cluster root.)
%For a cluster, we call the \defn{\outver{}} of a cluster tree edge to be the endpoint of this edge outside the cluster.
For a cluster, we call the endpoint of a cluster tree edge outside of the cluster a \defn{\outver{}}.
The \defn{\outvers{}} of a cluster is the set of \outvers{}
of all associated cluster tree edges.  Note that all \outvers{} except
for one are the cluster roots for
neighbor clusters.

\mysubsection{The \localgraph{} of a cluster}
We next define the concept of the \localgraph{} of a cluster, so that each query only needs to look up a constant number of associated \localgraph{s}.
An example of a \localgraph{} is shown in Figure~\ref{fig:localgraph} and a more formal definition is as follows.

\begin{definition}[\localgraph]
The \localgraph{} $G'$ of a cluster is defined as $(V_i \cup V_o,E')$. $V_i$ is the set of vertices in the cluster and $V_o$ is the set of \outvers{}. $E'$ consists of:
%A \localgraph{} of a specific cluster is $G'=(V',E')$, where $V'$ contains all the vertices $V_i$ within the local cluster and the \outvers{} of this cluster $V_o$ (i.e.\ $V'=V_i+V_o$).  Edges in the \localgraph{} include:
\begin{enumerate}
  \item The edges with both endpoints in this cluster and the associated clusters tree edges.
  \item For $c$ neighbor clusters sharing the same cluster label, we find the $c$ corresponding \outvers{} in $V_o$, and connect the vertices with $c-1$ edges.
  \item For an edge $(v_1, v_2)$ with only one endpoint $v_1$ in $V_i$, we find the \outver{} $v_o$ that is connected to $v_2$ on the cluster spanning tree, and create an edge from $v_1$ to $v_o$.
\end{enumerate}
\end{definition}

%An example of a \localgraph{} is shown in Figure~\ref{fig:localgraph}.
Figure~\ref{fig:localgraph} shows an example \localgraph{}.
Solid black lines are edges within the cluster and solid grey lines are cluster tree edges.  Neighbor clusters that share a label are shown with dashed outlines and connected via curved dashed lines.  $e_1$ and $e_2$ are examples of edges with only one endpoint in the cluster, and they are replaced by $e_1'$ and $e_2'$ respectively.

%The input to compute the \localgraph{s} includes the clusters spanning tree and the \imprep{} on the \clustergraph{}.
Computing a \localgraph{s} requires a spanning tree and \imprep{} of the \clustergraph{}.

\begin{lemma}\label{lem:locgraph-cons}
The cost to construct one \localgraph{} is $O(k^2)$ in expectation and $O(k^2\log n)$ \whp{} on the \seqmodel.
\end{lemma}
%\begin{proof}
%Each cluster in the \implicit{} has at most $k$ vertices, so finding the vertices $V_i$ takes $O(ck)$ cost where $c$ is the cost to compute the mapping $\rho(\cdot)$ of a vertex ($O(k)$ in expectation and $O(k\log n)$ \whp{}).  Since each vertex has a constant degree, there will be at most $O(k)$ neighbor clusters, so $|V_o|=O(k)$.   Enumerating and checking the other endpoint of the edges adjacent to $V_i$ takes $O(ck)$ cost.  Finding the new endpoint of an edge in category 3 requires constant cost after an $O(n/k)$ preprocessing of the Euler tour of the cluster spanning tree.  The number of neighbor clusters is $O(k)$ so checking the cluster labels and adding edges costs no more than $O(k)$.
%The overall cost to construct one \localgraph{} is thus $O(k^2)$ in expectation and $O(k^2\log n)$ \whp{}.
%After plugging in $c$ is $O(k)$ in expectation and $O(k\log n)$ \whp{}, the overall cost matches the bounds in the lemma.
%\end{proof}

\mysubsection{Queries}
With the definition of the \localgraph{} and the \imprep{} on the \clustergraph, biconnectivity queries can be answered. Here we take bridges as an example, and the queries for articulation points, \textbf{whether two vertices are biconnected}, \textbf{whether two vertices are 1-edge connected}, and \textbf{biconnected-component labels for edges} are shown in In Appendix~\ref{sec:biconn-sublinear}.
The preprocess steps for the queries are shown in an overview of Algorithm~\ref{algo:biconn}.
With the concepts and lemmas in this section, with a precomputation of $O(nk)$ cost and $O(n/k)$ writes, we can also do a normal query with $O(k^2)$ cost in expectation and $O(k^2\log n)$ \whp{} on \textbf{bridge-block tree}, \textbf{cut-block tree}, and \textbf{1-edge-connected components}.

There are three cases when deciding whether an edge is a bridge: a tree edge in the clusters spanning tree, a cross edge in the clusters spanning tree, or an edge with both endpoints in the same cluster.
Deciding which case to use takes constant operations.

A tree edge is a bridge if and only if it is a bridge of the \clustergraph{}, which we can mark with $O(n/k)$ writes while computing the \imprep{}. A cross edge cannot be a bridge.

For an edge within a cluster, we use the following lemma:
\begin{lemma}\label{lem:bridge-clust}
An edge with both endpoints in one cluster is a bridge if and only if it is a bridge in the \localgraph{} of the the corresponding cluster.
\end{lemma}
%\begin{proof}
%If an edge is a bridge in the original graph it means that there are no edges from the subtree of the lower vertex to the outside except for this edge itself.  By applying the modifications of the edges, this property still holds, which means the edge is still a bridge in the \localgraph{} and vice versa.
%\end{proof}

%Therefore, checking whether in a cluster one or several edges are bridges takes $O(k^2)$ on average and $O(k^2\log n)$ \whp{}.
Checking if an edge in a cluster is a bridge takes $O(k^2)$ on average and $O(k^2\log n)$ \whp{}.
\hide{
\myparagraph{Articulation points}  By a similar argument that a vertex is an articulation point of the original graph if and only if it is an articulation point of the associated \localgraph{}, checking whether articulation points in a cluster costs $O(k^2)$ on average and $O(k^2\log n)$ \whp{}.

%\bigskip
Within this framework, we can also support more query types.
}
\subsection{Parallelizing Biconnectivity Algorithms}\label{sec:abstract-biconn-depth}

The two biconnectivity algorithms discussed in this section are essentially highly parallelizable.
The key algorithmic components include Euler-tour construction, tree contraction, graph connectivity, prefix sum, and preprocessing LCA queries on the spanning tree.
Since the algorithms run each of the components a constant number of times, and the \depth{} of the algorithm is bounded by the \depth{} of graph connectivity, whose bound is provided in Section~\ref{sec:cc} ($O(\wcost^2\log^2 n)$ and $O(\wcost^{3/2}\log^3 n)$ \whp{} respectively when plugging in $\beta$ as $1/\wcost{}$ and $1/\sqrt\wcost{}$).\footnote{The classic parallel algorithms with polylogarithmic depth solve the Euler-tour construction, tree contraction, and prefix sum, since we here only require linear writes (in terms of number of vertices, $O(n)$ and $O(n/k)$ for the two algorithms) for both algorithms.}

For the sublinear-write algorithm, we assume that computations
within a cluster are sequential,
%then each query in a cluster requires $O(k^2)=O(\wcost{})$ expected work and $O(k^2\logn)=O(\wcost{}\log n)$ \whp{}.
and the work is upper bounded by $O(k^2)=O(\wcost{})$ in expectation and $O(k^2\log n)=O(\wcost{}\log n)$ \whp{} for any computations within a cluster.
This term is additive to the overall depth, since after acquiring the spanning tree (forest) of the clusters, we run all computations within the clusters in parallel and then run tree contraction and prefix sums based on the calculated values.
The $O(\wcost{})$ expected work ($O(\wcost{}\log n)$ \whp{}) is also the cost for a single biconnectivity query, and multiple ones can be queried in parallel.
%For most queries we can operate on each cluster in parallel and then run tree contraction and prefix sums based on the calculated values.
\hide{
The exception is for graph connectivity, where the \depth{} to search the neighbor clusters is multiplicative to the \depth{} of the BFS in the low-diameter decomposition.
%The exception is for graph connectivity, where each round of the BFS in the low-diameter decomposition requires querying cluster(s).
Thus the depth of this
algorithm is also bounded by the depth of graph connectivity, which is
$O(\wcost^{3/2}\log^3n)$ \whp{}.
}


