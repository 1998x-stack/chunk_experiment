\section{Graph Biconnectivity}\label{sec:biconn}

%\setcounter{theorem}{15}
In this section we introduce algorithms related to biconnectivity
and 1-edge connectivity queries.
We first review the classic approach
and its output, which requires $O(m)$ writes.
Then we propose a new BC (biconnected-component) labeling output, which has size $O(n)$ and can be constructed in $O(n)$ writes.
Queries such as determining bridges,
articulation points, and biconnected components can be answered in
$O(1)$ operations (and no writes) with the \imprep{}.  Finally we show how an \implicit{}
(as generated by Algorithm~\ref{algo:genclusters}) can be integrated into
the algorithm to further reduce the writes to $O(n/\sqrt{\wcost})$.

We begin by explaining sequential algorithms that we believe to be new and interesting.
Then in Section~\ref{sec:biconn-depth} we show that these algorithms are parallelizable.
For this section, we assume the size of the \local{}
memory in our model is $O(k\log n)$.

In this section we assume that the graph is connected.
If not, we can run the connectivity algorithm and
then run the algorithm on each component.  The results for a graph
are the union of the results of each of its connected components.

\subsection{The Classic Algorithm}

The classic parallel algorithm~\cite{tarjan1985efficient} to compute
biconnected components and bridges of a connected graph is based on
the Euler-tour technique.  The algorithm starts by building a
spanning tree $T$ rooted at some arbitrary vertex. Each vertex is
labeled by $\first(v)$
and $\last(v)$, which are the ranks of $v$'s first and last appearance
on the Euler tour of $T$.  The low
value $\low(v)$ and the high value $\high(v)$ of a vertex $v\in V$ are
defined as:
\begin{gather*}
\low(v)=\min\{w(u) \mid u \mb{ is in the subtree rooted at } v\}\\
\high(v)=\max\{w(u) \mid u \mb{ is in the subtree rooted at } v\}
\end{gather*}
where
\[w(u)=\min\{\first(u)\cup \{\first(u')\mid (u,u') \mb{ is a nontree
  edge}\}\}\footnote{If there are multiple edges
  $(u,u')$ in the graph, none of them are considered here.}\]

Namely, $\low(v)$ and $\high(v)$ indicate the first and last vertex
on the Euler tour that are connected by a nontree edge to the subtree rooted
at $v$.  The $\low(\cdot)$ and $\high(\cdot)$ values
can be computed by a reduce on each vertex followed by a leaffix\footnote{Leaffix is similar to prefix but defined on a tree and computed from the leaves to the root.} on
the subtrees.  The computation takes $O(\wcost{}\log n)$ \depth,
$O(m+\wcost{}n)$ work, and $O(n)$ writes on the \ourmodel\ model, by using the algorithm
and scheduling theorem in~\cite{BBFGGMS16}.  Then a tree edge is a
bridge if and only if the child's $\low$ and $\high$ is inclusively
within the range of $\first$ and $\last$ of the parent.
This parallel algorithm is asymptotically optimal even sequentially without considering asymmetric read and write costs.

The standard output of biconnected components~\cite{CLRS,JaJa92}
is an array $B[\cdot]$ with size $m$, where the $i$-th element in $B$
indicates which biconnected component the $i$-th edge belongs to.
Explicitly writing-out $B$ is costly in the asymmetric setting,
especially when $m\gg n$.
We provide an alternative
\imprep{} as output that only requires $O(n)$ writes.
%It essentially constructs an auxiliary graph which is a dual of the vertices and edges of the original graph, and runs connected components on the auxiliary graph.  The cost to just construct the auxiliary graph takes $O(m)$ writes, which can be costly

%\subsection{The \imprep{}}\label{sec:imprep}
\subsection{The BC Labeling}\label{sec:imprep}\label{sec:biconn-linear}

\input{figure-BClabeling}

Here we describe the \defn{BC (biconnected-component) labeling},
which effectively represents biconnectivity output in $O(n)$ space.
Instead of storing all edges within each biconnected
component, the \imprep{} stores a component label for each vertex, and a vertex
for each component.
An example of a BC labeling of a graph is shown in Figure~\ref{fig:eulertour}.
We will later show how to use this representation
along with an implicit decomposition to reduce the writes further.

\begin{definition}[\imprep{}]
  The \imprep{} of a connected graph with respect to a rooted spanning tree
  stores a \defn{vertex label}
  $l:V\backslash \{\textit{root}\}\to [C]$ where $C$ is the number of
  biconnected components in the graph, and a \defn{component head}
  $r:[C]\to V$ of each biconnected component.
\end{definition}

\begin{lemma}
  The \imprep{} of a connected graph can be computed in $O(m)$ operations
  and $O(n + m/\wcost)$ writes on the \seqmodel. Queries about bridges, articulation
  points, or biconnected components can be answered in no writes and $O(1)$ operations
  given a \imprep{} on a rooted spanning tree.
\end{lemma}

%We now describe the algorithm to generate the \imprep{} and the space bound of it, and finally explain how to query on it.
%We ignore duplicate edges in the graph since they do not affect the biconnectivity of the graph.  More specifically, when a tree edge exists, the duplicate non-tree edge is ignored.  Otherwise, only one non-tree edge is considered in the algorithm.   They do affect the checking of bridges, which will be discussed in the query section.

\myparagraph{The algorithm to compute \imprep{}} A vertex $v\in V$ (except for the root) is an articulation point iff there exists at least one child $u$ in the spanning tree that has $\first(v)\le\low(u)$ and $\high(u)\le\last(v)$.
We thus name the tree edge between such a pair of vertices to be a \defn{critical edge}.
The algorithm to compute the \imprep{} simply removes all critical edges and runs graph connectivity on all remaining graph edges.
Then the algorithm described in Section~\ref{sec:cc-linear} gives a unique component label that we assign as the vertex label.
For each component, its head is the vertex that is the parent of its cluster in the spanning tree.
Each connected component and its head form a biconnected component.
%The output now is the spanning tree, the labeling of each vertex (indicating the connected/biconnected component), and the articulation point of each biconnected component.

The correctness of the algorithm can be proven by showing the
equivalence of the result of this algorithm and that of the
Tarjan-Vishkin algorithm~\cite{tarjan1985efficient}.

Since the number of biconnected components is at most $n$, the spanning
tree, vertex labels, and component heads require only linear space. Therefore,
 the space requirement of the \imprep{} is $O(n)$.

\myparagraph{Query on \imprep{}}  We now show that queries are easy with the \imprep{}.
An edge is a bridge iff it is the only edge connecting a single-vertex component and its component head (the biconnected component contains this single edge).
%A bridge in a graph corresponds to a component that contains only one vertex and no duplicate edges between that vertex and the component head.
%The articulation points of a graph are the union of the component head for each biconnected component.  The only exception is the root of the spanning tree, which is an articulation point only when it is the component heads of two biconnected components.
The root of the spanning tree is an articulation point iff it is the head of at least two biconnected components. Any other vertex is an articulation point iff it is the head of at least one biconnected component.
A block-cut tree can also be generated from the \imprep{}: for each vertex create an edge from itself and its vertex label; and for each component create an edge from the label of this component to the component head.  We have a block-cut tree after removing degree-1 nodes corresponding to vertices.
%edges among the biconnected component of each vertex and the corresponding biconnected components of which this vertex is the articulation point.

This new representation can be interpreted as an implicit version of the standard
output~\cite{CLRS,JaJa92} of biconnected components,
i.e.\ the label of the biconnected component of each edge can be
reported in $O(1)$ operations.
This is simple: we report the label of the endpoint of the edge that is further from the root along the spanning tree.
%This is very simple: we just locate the two endpoints of the edge on the spanning tree, and report the vertex label of the lower vertex (root is on the top, and break tie arbitrarily).
The correctness can be shown in two cases: if the edge is a spanning tree edge, then the component label is stored in the further vertex; otherwise, the two vertices must have the same label and reporting either one gives the label of this biconnected component.

\bigskip Using \imprep{} gives the following theorem (see Section~\ref{sec:biconn-depth} for \depth\ analysis).
%The algorithm with the \imprep{} gives the following theorem (the \depth\ is analyzed later in Section~\ref{sec:biconn-depth}).
\begin{theorem}\label{thm:biconn-linear}
Articulation points, bridges, and biconnected components on the \ourmodel\ model take $O(m+n\wcost)$ expected work and $O(\wcost\min\{\wcost,m/n\}\log^2 n)$ \depth\ \whp{}, and each query can be answered in $O(1)$ work.
\end{theorem}

It is interesting to point out that the \imprep{} can efficiently answer queries that are non-trivial when using the standard output.
%actually answer more queries that are non-trivial by the standard output.
For example, consider the query: are two vertices in the same biconnected component?  %Namely, is there an articulated point that can disconnect any two given vertices?
With the \imprep{} we can answer the query by finding the label of the lower vertex and checking whether the higher one has the same label or is the component head of this component.  To the best of our knowledge, answering such queries on the standard representation can be hard, unless other information is also kept (e.g.\ a block-cut tree).

%Meanwhile, different biconnected components are only connected by articulation points.

%\subsection{The Algorithm with Sublinear Writes}
\subsection{Biconnectivity Oracle in Sublinear Writes}\label{sec:biconn-sublinear}
%\label{sec:bcc-sublinear}

Next we will show how the \implicit{} generated by Algorithm~\ref{algo:genclusters} can be integrated into the algorithm to further reduce writes in the case of bounded-degree graphs.  Our goal is as follows.

\begin{theorem}\label{thm:biconn}
There exists an algorithm that computes articulation points, bridges, and biconnected components of a bounded-degree graph in $O(n\sqrt{\wcost})$ expected work, $O(n/\sqrt{\wcost{}})$ writes and $O(\wcost^{3/2}\log^3n)$ \depth, and each query takes an expected $O(\wcost{})$ work and $O(\wcost{}\log n)$ work \whp{}, with no writes, on the \ourmodel\ model.
\end{theorem}

The overall idea of the new algorithm is to replace the vertices in the original graph with the clusters generated by Algorithm~\ref{algo:genclusters}.  We generate the \imprep{} on the \clustergraph{} (so the vertex labels are now the \defn{cluster labels}), and then show that a connected-type query can be answered using only the information on the \clustergraph{} and a constant number of associated clusters.
The cost analysis is based on the parameter $k$, and using $k=\sqrt{\wcost{}}$ gives the result in the theorem.

%For simplicity throughout the algorithm description we assume that the graph is bounded-degree.  Later we explain how to relax this restriction.

\subsubsection{The \imprep{} on the \clustergraph}

In the first step of the algorithm we generate the \imprep{} on the \clustergraph{}
with $k=\sqrt{\wcost}$.  We root this spanning tree and name it
the clusters spanning tree.
The head vertex of a cluster is chosen as the \defn{cluster root} for that cluster. (The root cluster does not have a cluster root.)
%The direct successor vertex (the head vertex) of a spanning tree edge
%is named as the \defn{cluster root} for that specific cluster.  (The root cluster does not have a cluster root.)
%For a cluster, we call the \defn{\outver{}} of a cluster tree edge to be the endpoint of this edge outside the cluster.
For a cluster, we call the endpoint of a cluster tree edge outside of the cluster an \defn{\outver{}}.
The \defn{\outvers{}} of a cluster is the set of \outvers{}
of all associated cluster tree edges.  Note that all \outvers{} except
for one are the cluster roots for
neighbor clusters.

\subsubsection{The \localgraph{} of a cluster}

We next define the concept of the \localgraph{} of a cluster, so that each query only needs to look up a constant number of associated \localgraph{s}.
An example of a \localgraph{} is shown in Figure~\ref{fig:localgraph} and a more formal definition is as follows.

\input{figure-localgraph}

\begin{definition}[\localgraph]
The \localgraph{} $G'$ of a cluster is defined as $(V_i \cup V_o,E')$. $V_i$ is the set of vertices in the cluster and $V_o$ is the set of \outvers{}. $E'$ consists of:
%A \localgraph{} of a specific cluster is $G'=(V',E')$, where $V'$ contains all the vertices $V_i$ within the local cluster and the \outvers{} of this cluster $V_o$ (i.e.\ $V'=V_i+V_o$).  Edges in the \localgraph{} include:
\begin{enumerate}
  \item The edges with both endpoints in this cluster and the associated clusters' tree edges.
  \item For $c$ neighbor clusters sharing the same cluster label, we find the $c$ corresponding \outvers{} in $V_o$, and connect the vertices with $c-1$ edges.
  \item For an edge $(v_1, v_2)$ with only one endpoint $v_1$ in $V_i$, we find the \outver{} $v_o$ that is connected to $v_2$ on the cluster spanning tree, and create an edge from $v_1$ to $v_o$.
\end{enumerate}
\end{definition}

%An example of a \localgraph{} is shown in Figure~\ref{fig:localgraph}.
Figure~\ref{fig:localgraph} shows an example \localgraph{}.
Solid black lines are edges within the cluster and solid grey lines are cluster tree edges.  Neighbor clusters that share a label are shown with dashed outlines and connected via curved dashed lines.  $e_1$ and $e_2$ are examples of edges with only one endpoint in the cluster, and they are replaced by $e_1'$ and $e_2'$ respectively.

%The input to compute the \localgraph{s} includes the clusters spanning tree and the \imprep{} on the \clustergraph{}.
Computing \localgraph{s} requires a spanning tree and \imprep{} of the \clustergraph{}.

\begin{lemma}\label{lem:locgraph-cons}
The cost to construct one \localgraph{} is $O(k^2)$ in expectation and $O(k^2\log n)$ \whp{} on the \seqmodel{} model.
\end{lemma}
\begin{proof}
Each cluster in the \implicit{} has at most $k$ vertices, so finding the vertices $V_i$ takes $O(ck)$ cost where $c$ is the cost to compute the mapping $\rho(\cdot)$ of a vertex ($O(k)$ in expectation and $O(k\log n)$ \whp{}).  Since each vertex has a constant degree, there will be at most $O(k)$ neighbor clusters, so $|V_o|=O(k)$.   Enumerating and checking the other endpoint of the edges adjacent to $V_i$ takes $O(ck)$ cost.  Finding the new endpoint of an edge in category 3 requires constant cost after an $O(n/k)$ preprocessing of the Euler tour of the cluster spanning tree.  The number of neighbor clusters is $O(k)$ so checking the cluster labels and adding edges costs no more than $O(k)$.
The overall cost to construct one \localgraph{} is thus $O(k^2)$ in expectation and $O(k^2\log n)$ \whp{}.
Since $c$ is $O(k)$ in expectation and $O(k\log n)$ \whp{}, the overall cost matches the bounds in the lemma.
\end{proof}

\subsubsection{Queries}

With the \localgraph{} and the \imprep{} on the \clustergraph{}, all sorts of biconnectivity queries can be made.
Some of them are easier while other queries require more steps, and the preprocessing steps are shown in an overview of Algorithm~\ref{algo:biconn}.

\input{algorithm-biconn}

%With the definition of the \localgraph{} and the \imprep{} on the \clustergraph, the queries can be answered.
%Now that we have defined \localgraph{} and \imprep{} on the \clustergraph, we discuss answering queries.
%After defining the \localgraph{} and \imprep{} on a \clustergraph, we can answer queries.

\myparagraph{Bridges}
%To check whether an edge is a bridge of the graph is relatively easy, which is either of the three cases: a tree edge in the clusters spanning tree, a cross edge, or an edge within a cluster (i.e.\ both endpoints are in the same cluster).
There are three cases when deciding whether an edge is a bridge: a tree edge in the clusters spanning tree, a cross edge in the clusters spanning tree, or an edge with both endpoints in the same cluster.
%It takes constant operations to identify the case of an edge.
Deciding which case to use takes constant operations.

A tree edge is a bridge if and only if it is a bridge of the \clustergraph{}, which we can mark with $O(n/k)$ writes while computing the \imprep{}. A cross edge cannot be a bridge.

For an edge within a cluster, we use the following lemma:
\begin{lemma}\label{lem:bridge-clust}
An edge with both endpoints in one cluster is a bridge if and only if it is a bridge in the \localgraph{} of the the corresponding cluster.
\end{lemma}
\begin{proof}
If an edge is a bridge in the original graph it means that there are no edges from the subtree of the lower vertex to the outside except for this edge itself.  By applying the modifications of the edges, this property still holds, which means the edge is still a bridge in the \localgraph{} and vice versa.
\end{proof}

%Therefore, checking whether in a cluster one or several edges are bridges takes $O(k^2)$ on average and $O(k^2\log n)$ \whp{}.
Checking if an edge in a cluster is a bridge takes $O(k^2)$ on average and $O(k^2\log n)$ \whp{}.

\myparagraph{Articulation points}  By a similar argument that a vertex is an articulation point of the original graph if and only if it is an articulation point of the associated \localgraph{}.
Given a query vertex $v$, we can check whether it is an articulation point in \localgraph{} associated to $v$, which costs $O(k^2)$ on average and $O(k^2\log n)$ \whp{}.

\bigskip
%\section{Other Biconnectivity Queries}\label{sec:morequires}

We now discuss how some more complex queries can be made.  To start with, we show some definitions and results that are used in the algorithms for queries.

\begin{definition}[root biconnectivity]
We say a vertex $v$ in a cluster $C$'s \localgraph{} is root-biconnected if $v$ and the cluster root have the same vertex label in $C$'s \localgraph{}.
\end{definition}

A root-biconnected vertex $v$ indicate that $v$ can connect to the ancestor clusters without using the cluster root (i.e.\ the cluster root is not an articulation point to cut $v$).  Another interpretation is that, there is no articulation point in cluster $C$ that disconnects $v$ from the \outver{} of the cluster root.

\begin{lemma}
Computing and storing the root biconnectivity of all \outvers{} in all
\localgraph{s} takes $O(nk)$ operations in expectation and $O(n/k)$ writes
on the \seqmodel.
\end{lemma}
The proof is straight-forward.  The cost to construct the \localgraph{s} and compute root biconnectivity is $O(nk)$, and since there are $O(n/k)$ clusters tree edges, storing the results requires $O(n/k)$ writes.

\myparagraph{Querying whether two vertices are biconnected}
Checking whether two vertices $v_1$ and $v_2$ can be disconnected by removing any single vertex in the graph is one of the most commonly-used biconnectivity-style queries.
To answer this query, our goal is to find the tree path between this pair of vertices and check whether there is an articulation point on this path that disconnects them.

The simple case is when $v_1$ and $v_2$ are within the same cluster.
We know that the two vertices are connected by a path via the vertices within the cluster. We can check whether any vertex on the path disconnects these two vertices using their vertex labels.

Otherwise, $v_1$ and $v_2$ are in different clusters $C_1$ and $C_2$.  Assume $C_{\smb{LCA}}$ is the cluster that contains the LCA of $v_1$ and $v_2$ (which can be computed by the LCA of $C_1$ and $C_2$ with constant cost) and $v_{\smb{LCA}}\in C_{\smb{LCA}}$ is the LCA vertex.
The tree path between $v_1$ and $v_2$ is from $v_1$ to $C_1$'s cluster root, and then to the cluster root of the \outver{} of $C_1$'s cluster root, and so on, until reaching $v_{\smb{LCA}}$, and the other half of the path can be constructed symmetrically.  It takes $O(k^2)$ expected cost to check whether any articulation point disconnects the paths in $C_1$, $C_2$ and $C_{\smb{LCA}}$.
For the rest of the clusters, since we have already precomputed and stored the root biconnectivity of all outside vertices, then applying a leafix on the clusters spanning tree computes the cluster containing the articulation point of each cluster root.
Therefore checking whether such an articulation point on the path between $C_1$ and $C_{\smb{LCA}}$ or between $C_2$ and $C_{\smb{LCA}}$ that disconnects $v_1$ and $v_2$ takes $O(1)$ cost.  Therefore checking whether two vertices are biconnected requires $O(k^2)$ cost in expectation and no writes.

\hide{
\begin{enumerate}
  \item if one cluster is the ancestor of the other (WLOG assume $C_1$ is the ancestor and $(v_{C_1},v_{C_3})$ is the cluster tree edge on the path between $C_1$ and $C_2$, $v_{C_1}\in C_1$ and $v_{C_3}\in C_3$), then (1) in $C_1$'s \localgraph{} $v_1$ must be biconnected to $v'$, (2) $v_2$ shares the same vertex label with its cluster root, and (3) $C_2$ and $C_3$ have the same cluster label;
  \item otherwise, both vertices share the same vertex labels with the cluster roots in the \localgraph{s} and the two clusters have the same cluster label.
\end{enumerate}
}

\myparagraph{Querying whether two vertices are 1-edge connected}
This is a similar query comparing to the previous one and the only difference is whether an edge, instead of a vertex, is able to disconnect two vertices.
The query can be answered in a similar way by checking whether a bridge disconnects the two vertices on their spanning tree path, which is related to the two clusters containing the two query vertices and the LCA cluster, and the precomputed information for the clusters on the tree path among these three clusters.
The cost for a query is also $O(k^2)$ operations in expectation and it requires no writes.

\myparagraph{Queries on biconnected-component labels for edges}  We now answer the standard queries~\cite{CLRS,JaJa92} of biconnected components: given an edge, report a unique label that represents the biconnected component this edge belongs to.

We have already described the algorithm to check whether any two vertices are biconnected, so the next step is to assign a unique label of each biconnected components, which requires the following lemma:
\begin{lemma}
A vertex in one cluster is either in a biconnected component that only contains vertices in this cluster, or biconnected with at least one \outver{} of this cluster.
\end{lemma}
\begin{proof}
Assume a vertex $v_1$ in this cluster $C$ is biconnected to another vertex $v_2$ outside the cluster, then let $v_o$ be the \outver{} of $C$ on the spanning tree path between $v_1$ and $v_2$, and $v_1$ is biconnected with $v_o$, which proves the lemma.
\end{proof}

With this lemma, we first compute and store the labels of the biconnected components on the cluster roots, which can be finished with $O(nk)$ expected operations and $O(n/k)$ writes with the \imprep{} on the \clustergraph{} and the the root biconnectivity of \outvers{} on all clusters.
Then for each cluster we count the number of biconnected components completely within this cluster.
Finally we apply a prefix sum on the numbers for the clusters to provide a unique label of each biconnected component in every cluster.
Although not explicitly stored, the vertex labels in each cluster can be regenerated with $O(k^2)$ operations in expectation and $O(k^2\log n)$ operations \whp{}, and a vertex label is either the same as that of an \outver{} which is precomputed, or a relative label within the cluster plus the offset of this cluster.

Similar to the algorithm discussed in Section~\ref{sec:imprep}, when a query comes, the edge can either be a cluster tree edge, a cross edge, or within a cluster.
For the first case the label biconnected component is the precomputed label for the (lower) cluster root.
For the second case we just report the vertex label of an arbitrary endpoint, and similarly for the third case the output is the vertex label of the lower vertex in the cluster.
The cost of a query is $O(k^2)$ in expectation and $O(k^2\log n)$ \whp{}.

\bigskip
With the concepts and lemmas in this section, with a precomputation of $O(nk)$ cost and $O(n/k)$ writes, we can also do a normal query with $O(k^2)$ cost in expectation and $O(k^2\log n)$ \whp{} on \textbf{bridge-block tree}, \textbf{cut-block tree}, and \textbf{1-edge-connected components}.

\subsection{Parallelizing Biconnectivity Algorithms}\label{sec:biconn-depth}

The two biconnectivity algorithms discussed in this section are essentially highly parallelizable.
The key algorithmic components include Euler-tour construction, tree contraction, graph connectivity, prefix sum, and preprocessing LCA queries on the spanning tree.
Since the algorithms run each of the components a constant number of times, and the \depth{} of the algorithm is bounded by the \depth{} of graph connectivity, whose bound is provided in Section~\ref{sec:cc} ($O(\wcost^2\log^2 n)$ and $O(\wcost^{3/2}\log^3 n)$ \whp{} respectively when plugging in $\beta$ as $1/\wcost{}$ and $1/\sqrt\wcost{}$).\footnote{The classic parallel algorithms with polylogarithmic depth solve the Euler-tour construction, tree contraction, and prefix sum, since we here only require linear writes (in terms of number of vertices, $O(n)$ and $O(n/k)$ for the two algorithms) for both algorithms.}

For the sublinear-write algorithm, we assume that computations
within a cluster are sequential,
%then each query in a cluster requires $O(k^2)=O(\wcost{})$ expected work and $O(k^2\logn)=O(\wcost{}\log n)$ \whp{}.
and the work is upper bounded by $O(k^2)=O(\wcost{})$ in expectation and $O(k^2\log n)=O(\wcost{}\log n)$ \whp{} for any computations within a cluster.
This term is additive to the overall depth, since after acquiring the spanning tree (forest) of the clusters, we run all computations within the clusters in parallel and then run tree contraction and prefix sums based on the calculated values.
The $O(\wcost{})$ expected work ($O(\wcost{}\log n)$ \whp{}) is also the cost for a single biconnectivity query, and multiple queries can be done in parallel.
%For most queries we can operate on each cluster in parallel and then run tree contraction and prefix sums based on the calculated values.
\hide{
The exception is for graph connectivity, where the \depth{} to search the neighbor clusters is multiplicative to the \depth{} of the BFS in the low-diameter decomposition.
%The exception is for graph connectivity, where each round of the BFS in the low-diameter decomposition requires querying cluster(s).
Thus the depth of this
algorithm is also bounded by the depth of graph connectivity, which is
$O(\wcost^{3/2}\log^3n)$ \whp{}.
}


