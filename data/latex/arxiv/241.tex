
\chapter[eMLTT: Martin-L\"{o}f's type theory with fibred computational effects]{eMLTT: Martin-L\"{o}f's type theory \\with fibred computational effects}
\label{chap:syntax}

\index{ e@eMLTT (our effectful dependently typed language)}
In this chapter we introduce and study eMLTT---our take on intensional MLTT with general computational effects. 
Specifically, eMLTT combines dependently typed programming in MLTT with features familiar from simply typed languages with computational effects such as CBPV and EEC. 
%
Similarly to CBPV and EEC, eMLTT makes a clear distinction between values (i.e., effect-free programs) and computations (i.e., potentially effectful programs), at both the level of types and the level of terms, with both kinds of types only allowed to depend on values---see the discussion in Section~\ref{sect:twoguidingquestions}.
%


In Section~\ref{sect:syntax}, we present the syntax of eMLTT; in Section~\ref{sect:judgements}, we 
equip eMLTT with a type system and define its equational theory; and in Section~\ref{sect:metatheory}, we establish some basic meta-theoretic properties of eMLTT, including the closure of well-formed expressions under weakening and substitution. We conclude this chapter by discussing syntax that is not part of the definition of eMLTT but that is nevertheless derivable. In Section~\ref{sect:derivableeliminationforms}, we show how to eliminate various value types into computations;  and in Section~\ref{sect:derivableequations}, we derive some standard equations that are familiar from other computational languages, such as the unit and associativity laws for sequential composition.

\section{Syntax}
\label{sect:syntax}



\index{ x@$x,y,\ldots$ (value variables)}
\index{ z@$z, \ldots$ (computation variables)}
We begin by assuming two disjoint and countably infinite sets of \emph{value variables} and 
\emph{computation variables}, respectively. 
We use $x,y,\ldots$ to range over value variables and 
\index{variable!value --}
$z, \ldots$ to range over computation variables. 
\index{variable!computation --}
The former are treated intuitionistically, as in MLTT, and enjoy structural properties of weakening and contraction. The latter are treated linearly, as in EEC, so as to ensure that effectful computations are not duplicated or discarded arbitrarily---an important property for the correct formulation of the elimination rule for the computational $\Sigma$-type, as discussed later in this section.


\index{ A@$A,B,\ldots$ (value types)}
\index{ C@$\ul{C},\ul{D},\ldots$ (computation types)}
\index{ V@$V,W,\ldots$ (value terms)}
\index{ M@$M,N,\ldots$ (computation terms)}
\index{ K@$K,L,\ldots$ (homomorphism terms)}
For types, we use $A,B,\ldots$ to range over \emph{value types}; 
and $\ul{C},\ul{D},\ldots$ to range over \emph{computation types}. 
For terms, we use $V,W,\ldots$ to range over \emph{value terms}; 
$M,N,\ldots$ to range over \emph{computation terms}; 
and $K,L,\ldots$ to range over \emph{homomorphism terms}. 
As is common for dependently typed languages, eMLTT's types and terms are given by a mutually inductive definition---see Definitions~\ref{def:types} and~\ref{def:terms}, respectively.
We discuss these different kinds of types and terms after their respective definitions.

\begin{definition}
\label{def:types}
\index{type!value --}
eMLTT's \emph{value} and \emph{computation types} are given by
\[
\begin{array}{r c l @{\qquad\qquad}l}
\index{ Nat@$\Nat$ (type of natural numbers)}
A & ::= & \Nat & \text{type of natural numbers}
\\
\index{ 1@$1$ (unit type)}
& \vertbar & 1 & \text{unit type}
\\
\index{ Sigma@$\Sigma \, x \hspace{-0.05cm}:\hspace{-0.05cm} A .\, B$ (value $\Sigma$-type)}
& \vertbar & \Sigma \, x \!:\! A .\, B & \text{value $\Sigma$-type}
\\
\index{ Product@$\Pi \, x \hspace{-0.05cm}:\hspace{-0.05cm} A .\, B$ (value $\Pi$-type)}
& \vertbar & \Pi \, x \!:\! A .\, B & \text{value $\Pi$-type}
\\
\index{ 0@$0$ (empty type)}
& \vertbar & 0 & \text{empty type}
\\
\index{ A@$A + B$ (coproduct type)}
& \vertbar & A + B & \text{coproduct type}
\\
\index{ V@$V =_A W$ (propositional equality)}
& \vertbar & V =_A W & \text{propositional equality}
\\
\index{ UC@$U \ul{C}$ (type of thunked computations)}
& \vertbar & U \ul{C} & \text{type of thunked computations}
\\
\index{ C@$\ul{C} \multimap \ul{D}$ (homomorphic function type)}
& \vertbar & \ul{C} \multimap \ul{D} & \text{homomorphic function type}
\index{type!computation --}
\\[5mm]
\index{ FA@$FA$ (type of computations that return values of type $A$)}
\ul{C} & ::= & FA & \text{type of computations that return values of type $A$}
\\
\index{ Sigma@$\Sigma \, x \hspace{-0.05cm}:\hspace{-0.05cm} A .\, \ul{C}$ (computational $\Sigma$-type)}
& \vertbar & \Sigma \, x \!:\! A .\, \ul{C} & \text{computational $\Sigma$-type}
\\
\index{ Product@$\Pi \, x \hspace{-0.05cm}:\hspace{-0.05cm} A .\, \ul{C}$ (computational $\Pi$-type)}
& \vertbar & \Pi \, x \!:\! A .\, \ul{C} & \text{computational $\Pi$-type}
\end{array}
\vspace{0.2cm}
\]
where 
\begin{itemize}
\item in $\Sigma \, x \!:\! A .\, B$ and $\Pi \, x \!:\! A .\, B$, the value variable $x$ is bound in $B$; and
\item in $\Sigma \, x \!:\! A .\, \ul{C}$ and $\Pi \, x \!:\! A .\, \ul{C}$, the value variable $x$ is bound in $\ul{C}$.
\end{itemize}
\end{definition}

We write $FVV(A)$ and $FVV(\ul{C})$ for the sets of \emph{free value variables} of a value type $A$ and a computation type $\ul{C}$, respectively.


eMLTT's \emph{value types} coincide with the types of MLTT, except for the type $U\ul{C}$ of thunks of computations of type $\ul{C}$ and the homomorphic function type $\ul{C} \multimap \ul{D}$; these are respectively based on analogous types in CBPV and EEC. The inhabitants of the former are suspended computations of type $\ul{C}$. The inhabitants of the latter are effectful functions that accept computations of type $\ul{C}$ as their arguments and additionally guarantee that the argument computation ``happens first" in function application---see the homomorphic lambda abstraction in Definition~\ref{def:terms}. 
%
To keep the presentation focussed on the computational aspects of eMLTT, we omit general inductive types and use the type of natural numbers as a representative example. If needed, general inductive types can be added using standard techniques, e.g., using $W$\!-types~\cite{MartinLof:Bibliopolis}. 
%
As is common in presentations of dependently typed languages, we use simply typed notation for $\Sigma\, x \!:\! A .\, B$ and $\Pi\, x \!:\! A .\, B$ when $x \not\in FVV(B)$, writing $A \times B$ and $A \to B$, respectively. 
\index{ A@$A \to B$ (non-dependent value function type)}
\index{ A@$A \times B$ (non-dependent value product type)} 


eMLTT's \emph{computation types} include the type $FA$ of computations that return values of type $A$. Computation types also include computational variants of the $\Sigma$- and $\Pi$-types, written $\Sigma\, x \!:\! A .\, \ul{C}$ and $\Pi\, x \!:\! A .\, \ul{C}$. The former is a natural dependently typed generalisation of EEC's computational tensor type. The latter is a natural dependently typed generalisation of EEC and CBPV's computational function type. Based on this relationship, we use simply typed notation for $\Sigma\, x \!:\! A .\, \ul{C}$ and $\Pi\, x \!:\! A .\, \ul{C}$ when $x \not\in FVV(\ul{C})$, writing  $A \otimes\, \ul{C}$ and $A \to \ul{C}$, respectively. 
\index{ A@$A \to \ul{C}$ (non-dependent computational function type)}%
\index{ A@$A \otimes\, \ul{C}$ (non-dependent computational tensor type)}%
Compared to EEC and CBPV, we omit binary (and nullary) coproducts and products of 
computation types. In the models we study in this thesis, these are special cases 
of $\Sigma\, x \!:\! A .\, \ul{C}$ and $\Pi\, x \!:\! A .\, \ul{C}$. In order to define them 
in terms of $\Sigma\, x \!:\! A .\, \ul{C}$ and $\Pi\, x \!:\! A .\, \ul{C}$ in the language itself, 
one needs to extend eMLTT, e.g., either with large elimination forms or universes (see the next paragraph).

We note that as our focus is on the general principles of combining  
dependent types and computational effects, we treat type-dependency 
abstractly in most parts of this thesis, leaving the exact means through 
which one defines dependent types implicit (with the exception of  
propositional equality). Analogously to accommodating general 
inductive types, one can easily extend eMLTT using standard techniques. For example,  
one can extend its value and computation types 
with large elimination forms, such as 
\[
\begin{array}{r c l}
A & ::= & \ldots \,\,\,\vertbar\,\,\, \pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {} A
\\[2mm]
\ul{C} & ::= & \ldots \,\,\,\vertbar\,\,\, \pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {} \ul{C}
\end{array}
\]
and analogously for eliminating other value types. 
Alternatively, one could also extend eMLTT with universes 
of value and computation types, e.g., as discussed and used in Section~\ref{section:usinghandlersforreasoning}.
Finally, we note that in Section~\ref{sect:typedependencyonfeffects} we 
discuss a possible way to also accommodate type-dependency 
on computations directly, rather than only via thunks.


We also highlight that eMLTT is a minor extension of the language the author studied in the paper~\cite{Ahman:FibredEffects} large parts of this thesis are based on. eMLTT additionally includes the empty type, the coproduct type, and the homomorphic function type. The first two extensions better align it with dependently typed  languages such as Agda and Idris, and enable us to specify signatures of fibred algebraic effects in Chapter~\ref{chap:fibalgeffects}; the latter extension enables us to eliminate various value types into computations.
We also note that in Section~\ref{sect:continuousfamilies} we extend the core language presented in this chapter with general recursion, and in Chapters~\ref{chap:fibalgeffects} and~\ref{chap:handlers} with  algebraic effects and their handlers.

\begin{definition}
\label{def:terms}
eMLTT's \emph{value}, \emph{computation}, and \emph{homomorphism terms} are given by
\index{term!value --}
\[
\begin{array}{r c l @{\qquad\qquad}l}
V & ::= & x & \text{value variable}
\\
& \vertbar & \zero & \text{zero}
\\
& \vertbar & \suc V & \text{successor}
\\
& \vertbar & \natrec {x.\,A} {V_z} {y_1.\, y_2.\, V_s} {V} & \text{primitive recursion}
\\
& \vertbar & \star & \text{unit}
\\
& \vertbar & \langle V , W \rangle_{(x : A).\, B}  & \text{pairing}
\\
& \vertbar & \pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\, B} W & \text{pattern-matching}
\\
& \vertbar & \lambda \, x \!:\! A .\, V & \text{lambda abstraction}
\\
& \vertbar & V(W)_{(x : A).\,B}  & \text{function application}
\\
& \vertbar & \absurd {x.\,A} V & \text{empty case analysis}
\\
& \vertbar & \inl {A + B} V & \text{left injection}
\\
& \vertbar & \inr {A + B} V & \text{right injection}
\\
& \vertbar & \mathtt{case~} V \mathtt{~of}_{x.\,B} \mathtt{~} ({\inl {\!} {\!\!(y_1 \!:\! A_1)} \mapsto W_1}, & \text{binary case analysis}
\\[-1mm]
&& \hspace{2.55cm} {\inr {\!} {\!\!(y_2 \!:\! A_2)} \mapsto W_2})
\\
& \vertbar & \refl A V & \text{reflexivity of}
\\[-2mm]
& & & \text{propositional equality}
\\
& \vertbar & \pathind A {x_1.\, x_2.\, x_3.\, B} {y.\, W} {V_1} {V_2} {V_p} & \text{elimination of}
\\[-2mm]
& & & \text{propositional equality}
\\
& \vertbar & \thunk M & \text{thunked computation}
\\
& \vertbar & \lambda\, z \!:\! \ul{C} .\, K & \text{homomorphic}
\\[-2mm]
& & & \text{lambda abstraction}
\\[5mm]
\index{term!computation --}
M & ::= & \return V & \text{returning a value}
\\
& \vertbar & \doto M {x \!:\! A} {\ul{C}} N & \text{sequential composition}
\\
& \vertbar & \langle V , M \rangle_{(x : A).\, \ul{C}} & \text{computational pairing}
\\
& \vertbar & \doto M {(x \!:\! A, z \!:\! \ul{C})} {\ul{D}} K & \text{computational}
\\[-2mm]
& & & \text{pattern-matching}
\\
& \vertbar & \lambda \, x \!:\! A .\, M & \text{computational}
\\[-2mm]
& & & \text{lambda abstraction}
\end{array}
\]

\[
\begin{array}{r c l @{\qquad\qquad}l}
& \vertbar & M(V)_{(x : A).\,\ul{C}}  & \text{computational}
\\[-2mm]
& & & \text{function application}
\\
& \vertbar & \force {\ul{C}} V & \text{forcing a}
\\[-2mm]
& & & \text{thunked computation}
\\
& \vertbar & V(M)_{\ul{C}, \ul{D}} & \text{homomorphic}
\\[-2mm]
& & & \text{function application}
\\[5mm]
\index{term!homomorphism --}
K & ::= & z & \text{computation variable}
\\
& \vertbar & \doto K {x \!:\! A} {\ul{C}} M & \text{sequential composition}
\\
& \vertbar & \langle V , K \rangle_{(x : A).\, \ul{C}} & \text{computational pairing}
\\
& \vertbar & \doto K {(x \!:\! A, z \!:\! \ul{C})} {\ul{D}} L & \text{computational}
\\[-2mm]
&&& \text{pattern-matching}
\\
& \vertbar & \lambda \, x \!:\! A .\, K & \text{computational}
\\[-2mm]
&&& \text{lambda abstraction}
\\
& \vertbar & K(V)_{(x : A).\, \ul{C}}  & \text{computational}
\\[-2mm]
&&& \text{function application}
\\
& \vertbar & V(K)_{\ul{C}, \ul{D}} & \text{homomorphic}
\\[-2mm]
&&& \text{function application}
\end{array}
\]
where
\begin{itemize}
\item in $\natrec {x.\,A} {V_z} {y_1.\, y_2.\, V_s} {V}$, the value variable $x$ is bound in $A$, and the value variables $y_1$ and $y_2$ are bound in $V_s$;
\item in $\langle V , W \rangle_{(x : A).\, B}$, the value variable $x$ is bound in $B$;
\item in $\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\, B} W$, the value variable $x_1$ is bound in $A_2$ and $W$, the value variable $x_2$ is bound in $W$, and the value variable $y$ is bound in $B$;
\item in $\lambda \, x \!:\! A .\, V$, the value variable $x$ is bound in $V$;
\item in $V(W)_{(x : A).\,B}$, the value variable $x$ is bound in $B$;
\item in $\absurd {x.\,A} V$, the value variable $x$ is bound in $A$
\item in $\case V {x.\, B} {\inl {\!} {\!\!(y_1 \!:\! A_1)} \mapsto W_1} {\inr {\!} {\!\!(y_2 \!:\! A_2)} \mapsto W_2}$, the value variable $x$ is bound in $B$, the value variable $y_1$ is bound in $W_1$, and the value variable $y_2$ is bound in $W_2$;
\item in $\pathind A {x_1.\, x_2.\, x_3.\, B} {y.\, W} {V_1} {V_2} {V_p}$, the value variables $x_1$, $x_2$,  and $x_3$ are bound in $B$, and the value variable $y$ is bound in $W$;
\item in $\lambda\, z \!:\! \ul{C} .\, K$, the computation variable $z$ is bound in $K$;
\item in $\doto M {x \!:\! A} {\ul{C}} N$, the value variable $x$ is bound in $N$;
\item in $\langle V , M \rangle_{(x : A).\, \ul{C}}$, the value variable $x$ is bound in $\ul{C}$;
\item in $\doto M {(x \!:\! A, z \!:\! \ul{C})} {\ul{D}} K$, the value variable $x$ is bound in $\ul{C}$ and $K$, and the computation variable $z$ is bound in $K$;
\item in $\lambda \, x \!:\! A .\, M$, the value variable $x$ is bound in $M$;
\item in $M(V)_{(x : A).\,\ul{C}}$, the value variable $x$ is bound in $\ul{C}$;
\item in $\doto K {x \!:\! A} {\ul{C}} M$, the value variable $x$ is bound in $M$;
\item in $\langle V , K \rangle_{(x : A).\, \ul{C}}$, the value variable $x$ is bound in $\ul{C}$;
\item in $\doto K {(x \!:\! A, z \!:\! \ul{C})} {\ul{D}} L$, the value variable $x$ is bound in $\ul{C}$ and $L$, and the computation variable $z$ is bound in $L$;
\item in $\lambda \, x \!:\! A .\, K$, the value variable $x$ is bound in $K$; and
\item in $K(V)_{(x : A).\, \ul{C}}$, the value variable $x$ is bound in $\ul{C}$.
\end{itemize}
\end{definition}

\index{ fst@$\fst$ (first projection, derived from pattern-matching)}
\index{ snd@$\snd$ (second projection, derived from pattern-matching)}
For better readability, we sometimes use left and right \emph{projections} instead of pattern-matching in our examples. These projections are derived from pattern-matching as
\[
\begin{array}{c}
\fst V \defeq \pmatch {V} {(x_1 \!:\! A , x_2 \!:\! B)} {} {x_1}
\qquad
\snd V \defeq \pmatch {V} {(x_1 \!:\! A , x_2 \!:\! B)} {} {x_2}
\end{array}
\]

We write $FVV(V)$, $FVV(M)$, and $FVV(K)$ 
for the sets of \emph{free value variables} of a value term $V$, a computation term $M$, and a homomorphism term $K$, respectively. In particular, the free value variables of terms also include the free variables of type annotations. Regarding\, \emph{free computation variables}, we have the following properties:

\begin{proposition}
\mbox{}
\begin{enumerate}
\item[(a)] Value types $A$, computation types $\ul{C}$, value terms $V$, and computation terms $M$ do not contain free computation variables.
\item[(b)] Every homomorphism term $K$ contains exactly one \emph{free computation variable} which we write  as $FCV(K)$.
\index{ FCV@$FCV(K)$ (free computation variable of $K$)}
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$ and $(b)$ by simultaneous induction: the former by induction on the structure of $A$, $\ul{C}$, $V$, and $M$, and the latter by induction on the structure of $K$.
\end{proof}

eMLTT's \emph{value terms} coincide with the terms of MLTT, except for thunked computations 
$\thunk M$ and the homomorphic lambda abstraction $ \lambda\, z \!:\! \ul{C} .\, K$. 
In contrast to CBPV, eMLTT's value terms include elimination forms for value types  
in order to accommodate effect-free programs that the types of eMLTT could depend on.

eMLTT's \emph{computation terms} include standard combinators for programming with computational effects, namely, returning values and sequential composition of computations. They also include introduction and elimination forms for the computational $\Sigma$- and $\Pi$-types, forcing of thunked computations, and homomorphic function applications. 
We deliberately use similar notation for sequential composition and computational pattern-matching---compare $\doto M {x \!:\! A} {} N$ and $\doto M {(x \!:\! A, z \!:\! \ul{C})} {} K$---so as to emphasise that  the effects of $M$ are performed before the effects of $N$ and $K$, respectively. Further, notice that in order to account for the fact that $M$ produces a pair of a value and a computation, the second term in computational pattern-matching is necessarily a homomorphism term. 

eMLTT's \emph{homomorphism terms} are analogous to EEC's linear terms. Similarly to computation terms, they also include sequential composition, and introduction and elimination forms for the computational $\Sigma$- and $\Pi$-types. However, unlike computation terms, they do not include returning values and forcing of thunked computations but instead include computation variables $z$ that are required to be used linearly. Further, the definition of homomorphism terms also requires computation variables to be used so that effects of a computation bound to $z$ always ``happen first" in a term containing it. For example, when eliminating a computational pair $\pair V M$, the effects of $M$ are guaranteed to be performed before the effects of $K$ in ${\dtensorlet {(x \!:\! A , z \!:\! \ul{C})} {\pair V M} K}$.

This linear use of computation variables, together with leaving out returning values and forcing thunked computations, ensures that homomorphism terms denote algebra homomorphisms in the examples based on Eilenberg-Moore algebras of monads (see Section~\ref{sect:fibredmonadsandEMfibs}), or on algebraic effects (see Section~\ref{sect:fibalgeffectsmodel}): hence their name. 
A similar form of linearity is also present in CBPV with stacks, as defined in~\cite[\S 2.3.4]{Levy:CBPV}. Indeed,  homomorphism terms can be viewed as a programmer-friendly syntax for dependently typed CBPV stack terms (or equivalently, for one-hole evaluation contexts). 

Later, in Section~\ref{sect:alternativepresentations}, we also briefly discuss an alternative presentation of eMLTT in which one omits computation variables and homomorphism terms, and instead uses value variables and computation terms, in combination with equational proof obligations ensuring that the value variables are used analogously to computation variables.

It is worth observing that compared to the corresponding terms in CBPV and EEC, eMLTT's computation terms (resp.~homomorphism terms) do not include elimination forms for value types as they can be easily derived from the corresponding elimination forms included in eMLTT's value terms using thunking and forcing (resp.~homomorphic lambda abstraction and function application). We show this in Section~\ref{sect:derivableeliminationforms}.




The reader should also note that eMLTT's terms are decorated with more type annotations than one usually expects to see in a high-level (dependently typed) programming language. We later use these annotations to define the interpretation of eMLTT in fibred adjunction models by recursion on (raw) types and terms rather than the (non-unique) typing derivations. This is a standard technique in the literature  to avoid having to define the interpretation  simultaneously with proving its coherence, see~\cite{Streicher:Semantics,Hofmann:SyntaxAndSemantics}.
%
Nevertheless, we conjecture that this annotated syntax is equivalent to the corresponding unannotated syntax, based on analogous results for MLTT, e.g., see~\cite{Streicher:Semantics,Castellan:Report}. We leave a formal proof of this conjecture for future work. However, for better readability, we often omit these annotations in our examples and informal discussion.


We conclude this section by establishing some useful properties of substitution in eMLTT. 
In order to keep our definitions and propositions concise and readable, we refer to types and terms collectively as \emph{expressions} and use $E, \ldots$ to range over them. In detail, expressions are given by the following grammar:
\index{expression}
\index{ E@$E, \ldots$ (expressions, collective name for types and terms of eMLTT)}
\[
E \,\,\,\,::=\,\,\,\, A \,\,\,\,\vertbar\,\,\,\, \ul{C} \,\,\,\,\vertbar\,\,\,\, V \,\,\,\,\vertbar\,\,\,\, M \,\,\,\,\vertbar\,\,\,\, K
\]

\index{variable!-- convention}
When working with expressions involving bound variables, we follow the standard conventions:
%
i) we identify expressions that differ only in the names of bound variables, i.e., we identify expressions up-to $\alpha$-equivalence; and ii) we assume that in any mathematical context (definitions, theorems, proofs, etc.), the bound variables of expressions are chosen to be different from the free variables appearing in that context.

\begin{definition}
\label{def:substvaluevariables}
\index{substitution!-- of a value term}
The \emph{substitution of a value term $V$ for a value variable $x$ in an expression $E$}, written $E[V/x]$, 
\index{ E@$E[V/x]$ (substitution of $V$ for $x$ in $E$)}
is defined by recursion on the structure of $E$ as follows:
\[
\begin{array}{l c l}
\Nat[V/x] & \defeq & \Nat
\\
& \ldots &
\\
x[V/x] & \defeq & V
\\
y[V/x] & \defeq & y \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\,\,\,\, (\text{if~} x \neq y)
\\
& \ldots &
\\
(\return W)[V/x] & \defeq & \return (W[V/x])
\\
(\doto M {y \!:\! A} {\ul{C}} N)[V/x] & \defeq & \doto {M[V/x]} {y \!:\! A[V/x]} {\ul{C}[V/x]} {N[V/x]}
\\
& \ldots &
\end{array}
\]

\[
\hspace{-3.9cm}
\begin{array}{l c l}
(K(W)_{(y : A).\, \ul{C}})[V/x] & \defeq & (K[V/x])(W[V/x])_{(y : A[V/x]).\, \ul{C}[V/x]}
\\
(W(K)_{\ul{C}, \ul{D}})[V/x] & \defeq & (W[V/x])(K[V/x])_{\ul{C}[V/x], \ul{D}[V/x]}
\end{array}
\]
where the bound value variables are assumed to be different from the value variable $x$ we are substituting $W$ for, according to the variable conventions we have adopted.
\end{definition}

Later, in Section~\ref{sect:completeness}, we also demonstrate that this definition of unary 
substitutions naturally generalises to a definition of simultaneous substitutions. 
We then use simultaneous substitutions in op.~cit.~when constructing the classifying categorical model of eMLTT, and in Chapters~\ref{chap:fibalgeffects} and~\ref{chap:handlers} when 
extending eMLTT with algebraic effects and their handlers. Meanwhile, we found it more 
convenient to work with unary substitutions when presenting the well-formed syntax and meta-theory of eMLTT (Sections~\ref{sect:judgements} and~\ref{sect:metatheory}), and its denotational semantics and the soundness proof (Sections~\ref{sect:interpretation} and~\ref{sect:soundness}). 



\begin{proposition}
Given a value variable $x$, a value term $V$, and an expression $E$, then $E[V/x]$ is the same kind of expression as $E$, e.g., if $E$ is a computation term, then  $E[V/x]$ is also a computation term.
\end{proposition}

\begin{proof}
By induction on the structure of $E$.
\end{proof}

\begin{proposition}
\label{prop:freevariablesofsubsstitution}
Given a value variable $x$, a value term $V$, and an expression $E$, then $FVV(E[V/x]) \subseteq (FVV(E) - \{x\}) \,\cup\, FVV(V)$.
\end{proposition}

\begin{proof}
By induction on the structure of $E$.
\end{proof}


\begin{proposition}
\label{prop:valuesubstlemma1}
Given a value variable $x$, a value term $V$, and an expression $E$ such that $x \not\in FVV(E)$, then $E[V/x] = E$.
\index{ FVV@$FVV(E)$ (set of free value variables of $E$)}
\end{proposition}

\begin{proof}
By induction on the structure of $E$.
\end{proof}

\begin{proposition}
\label{prop:valuesubstlemma2}
Given a value variable $x$ and an expression $E$, then $E[x/x] = E$.
\end{proposition}

\begin{proof}
By induction on the structure of $E$.
\end{proof}

\begin{proposition}
\label{prop:valuesubstlemma3}
Given value variables $x$ and $y$, value terms $W_1$ and $W_2$, and an expression $E$ such that $x \neq y$ and $x \not\in FVV(W)$, then $E[V/x][W/y] = E[W/y][V[W/y]/x]$.
\end{proposition}

\begin{proof}
By induction on the structure of $E$.
\end{proof}


\begin{definition}
\index{substitution!-- of a computation term}
The \emph{substitution of a computation term $M$ for a computation variable $FCV(K) = z$ in a homomorphism term $K$}, written $K[M/z]$, is defined by recursion on the structure of $K$ as follows:
\index{ K@$K[M/z]$ (substitution of $M$ for $z$ in $K$)}
\[
\begin{array}{l c l}
z[M/z] & \defeq & M
\\
(\doto K {x \!:\! A} {\ul{C}} N)[M/z] & \defeq & \doto {K[M/z]} {x \!:\! A} {\ul{C}} N
\\
(\langle V , K \rangle_{(x : A).\, \ul{C}})[M/z] & \defeq & \langle V , K[M/z] \rangle_{(x : A).\, \ul{C}}
\\
(\doto K {(x \!:\! A, z' \!:\! \ul{C})} {\ul{D}} L)[M/z] & \defeq & \doto {K[M/z]} {(x \!:\! A, z' \!:\! \ul{C})} {\ul{D}} L
\\
(\lambda \, x \!:\! A .\, K)[M/z] & \defeq & \lambda \, x \!:\! A .\, K[M/z]
\\
(K(V)_{(x : A).\, \ul{C}})[M/z] & \defeq & (K[M/z])(V)_{(x : A).\, \ul{C}}
\\
(V(K)_{\ul{C}, \ul{D}})[M/z] & \defeq & V(K[M/z])_{\ul{C}, \ul{D}}
\end{array}
\]
\end{definition}
\vspace{0.2cm}

\begin{proposition}
Given a homomorphism term $K$ with $FCV(K) = z$ and a computation term $M$, then $K[M/z]$ is a computation term.
\end{proposition}

\begin{proof}
By induction on the structure of $K$.
\end{proof}

\begin{proposition}
\label{prop:compsubstvaluesubst}
Given a homomorphism term $K$ with $FCV(K) = z$, a computation term $M$, a value variable $x$, and a value term $V$, then $K[M/z][V/x] = K[V/x][M[V/x]/z]$.
\end{proposition}

\begin{proof}
By induction on the structure of $K$.
\end{proof}

\begin{definition}
\index{substitution!-- of a homomorphism term}
The \emph{substitution of a homomorphism term $K$ \,for a computation variable $FCV(L) = z$ in a homomorphism term $L$}, written $L[K/z]$, is defined by recursion on the structure of $L$ as follows:
\index{ L@$L[K/z]$ (substitution of $K$ for $z$ in $L$)}
\[
\begin{array}{l c l}
z[K/z] & \defeq & K
\\
(\doto L {x \!:\! A} {\ul{C}} N)[K/z] & \defeq & \doto {L[K/z]} {x \!:\! A} {\ul{C}} N
\\
(\langle V , L \rangle_{(x : A).\, \ul{C}})[K/z] & \defeq & \langle V , L[K/z] \rangle_{(x : A).\, \ul{C}}
\\
(\doto {L_1} {(x \!:\! A, z' \!:\! \ul{C})} {\ul{D}} {L_2})[K/z] & \defeq & \doto {L_1[K/z]} {(x \!:\! A, z' \!:\! \ul{C})} {\ul{D}} {L_2}
\\
(\lambda \, x \!:\! A .\, L)[K/z] & \defeq & \lambda \, x \!:\! A .\, L[K/z]
\\
(L(V)_{(x : A).\, \ul{C}})[K/z] & \defeq & (L[K/z])(V)_{(x : A).\, \ul{C}}
\\
(V(L)_{\ul{C}, \ul{D}})[K/z] & \defeq & V(L[K/z])_{\ul{C}, \ul{D}}
\end{array}
\]
\end{definition}
\vspace{0.2cm}

\begin{proposition}
Given homomorphism terms $K$ and $L$ with $FCV(K) = z$, then $K[L/z]$ is also a homomorphism term.
\end{proposition}

\begin{proof}
By induction on the structure of $K$.
\end{proof}

\begin{proposition}
\label{prop:compvariableofhomsubst}
Given homomorphism terms $K$ and $L$ with $FCV(L) = z$, then $FCV(L[K/z]) = FCV(K)$.
\end{proposition}

\begin{proof}
By induction on the structure of $L$.
\end{proof}

\begin{proposition}
\label{prop:homsubstlemma}
Given a homomorphism term $K$ with $FCV(K) \!=\! z$, then $K[z/z] \!=\! K$.
\end{proposition}

\begin{proof}
By induction on the structure of $K$.
\end{proof}

\begin{proposition}
\label{prop:hompsubstvaluesubst}
Given homomorphism terms $K$ and $L$ with $FCV(L) = z$, a value variable $x$, and a value term $V$, then $L[K/z][V/x] = L[V/x][K[V/x]/z]$.
\end{proposition}

\begin{proof}
By induction on the structure of $K$.
\end{proof}

\begin{proposition}
\label{prop:hompsubstcompsubst}
Given homomorphism terms $K$ and $L$ with $FCV(L) = z_1$ and \linebreak $FCV(K) = z_2$, and a computation term $M$, then $L[K/z_1][M/z_2] = L[K[M/z_2]/z_1]$.
\end{proposition}

\begin{proof}
By induction on the structure of $K_1$.
\end{proof}

\begin{proposition}
\label{prop:hompsubsthomsubst}
Given homomorphism terms $K_1$, $K_2$, and $K_3$ with $FCV(K_1) = z_1$ and $FCV(K_2) = z_2$, then $K_1[K_2/z_1][K_3/z_2] = K_1[K_2[K_3/z_2]/z_1]$.
\end{proposition}

\begin{proof}
By induction on the structure of $K_1$.
\end{proof}

\section{Well-formed syntax and equational theory}
\label{sect:judgements}

In this section we present the well-formed syntax of eMLTT and its equational theory.


First, we define the notions of value and computation contexts, and prove some basic properties about the former.

\begin{definition}
\label{def:contexts}
\index{context!value --}
\index{ G@$\Gamma$ (value context)}
A \emph{value context} $\Gamma$ is a finite list $x_1 \!:\! A_1, \ldots, x_n \!:\! A_n$ of pairs of value variables $x_i$ and value types $A_i$ such that all the value variables $x_i$ are distinct. We write $\diamond$ for the \emph{empty value context} and $V\!ars(\Gamma)$ for the \emph{set of value variables} in $\Gamma$.
\index{ @$\diamond$ (empty value context)}
\index{ Vars@$Vars(\Gamma)$ (set of variables in $\Gamma$)}
\end{definition}

\begin{definition}
\index{context!computation --}
A \emph{computation context} $z \!:\! \ul{C}$ is a pair of a computation variable $z$ and a computation type $\ul{C}$.
\index{ z@$z : \ul{C}$ (computation context)}
\end{definition}

\begin{definition}
Given two value contexts $\Gamma_1$ and $\Gamma_2$, we say that $\Gamma_1$ and $\Gamma_2$ are \emph{disjoint} when $V\!ars(\Gamma_1) \,\cap\, V\!ars(\Gamma_2) = \emptyset$.
\end{definition}

\begin{definition}
Given two disjoint value contexts $\Gamma_1$ and $\Gamma_2$, their \emph{concatenation} is written $\Gamma_1,\Gamma_2$, and defined by recursion on the length of $\Gamma_2$:
\index{ G@$\Gamma_1,\Gamma_2$ (concatenation of value contexts)}
\[
\begin{array}{l c l}
\Gamma_1,\diamond & \defeq & \Gamma_1
\\
\Gamma_1, (\Gamma_2,x \!:\! A) & \defeq & (\Gamma_1,\Gamma_2), x \!:\! A
\end{array}
\]
where the second case is well-defined because of the disjointness assumption.
\end{definition}

\begin{proposition}
\label{prop:unionofvariablesinconctexts}
Given that $\Gamma_1,\Gamma_2$ exists, then $V\!ars(\Gamma_1,\Gamma_2) = V\!ars(\Gamma_1) \,\cup\, V\!ars(\Gamma_2)$.
\end{proposition}

\begin{proof}
By induction on the length of $\Gamma_2$.
\end{proof}


Next, we note that the notion of substitution of value terms for value variables extends straightforwardly from value types to value contexts:

\begin{definition}
\label{def:contextsubstitution}
The \emph{substitution of a value term $V$ for a value variable $x$ in a value context $\Gamma = y_1 \!:\! A_1, \ldots, y_n \!:\! A_n$}, written $\Gamma[V/x]$, is defined by 
\index{ G@$\Gamma[V/x]$ (substitution of $V$ for $x$ in $\Gamma$)}
\[
\Gamma[V/x] \defeq y_1 \!:\! A_1[V/x], \ldots, y_n \!:\! A_n[V/x]
\]
\end{definition}

\begin{proposition}
\label{prop:contextsubstlemma}
Propositions~\ref{prop:valuesubstlemma1},~\ref{prop:valuesubstlemma2}, and~\ref{prop:valuesubstlemma3} extend to Definition~\ref{def:contextsubstitution}.
\end{proposition}

\begin{proof}
By applying the cases of value types of Propositions~\ref{prop:valuesubstlemma1},~\ref{prop:valuesubstlemma2}, and~\ref{prop:valuesubstlemma3} to each of the value types $A_i$ in the given value context $\Gamma = y_1 \!:\! A_1, \ldots, y_n \!:\! A_n$.
\end{proof}


Finally, we define the well-formed syntax of eMLTT and its equational theory.
To this end, it is worth recalling that eMLTT is based on MLTT with intensional propositional equality. As a consequence, we do not include an $\eta$-equation for the elimination form of propositional equality. 
We also do not include an $\eta$-equation for primitive recursion. In both cases, we do so to avoid a known source of undecidability for the equational theory of eMLTT, see~\cite{Hofmann:Thesis} and~\cite{Okada:Rewriting}, respectively. While we do not investigate normalisation of eMLTT's equational theory in this thesis, it would be an important property for future implementations of eMLTT (see Section~\ref{sect:normalisationandimplementation}). 

In addition, as discussed in Section~\ref{sect:twoguidingquestions}, the rules for sequential composition (both for computation and homomorphism terms) disallow the type of the second computation to depend on the variable bound by sequential composition. As also discussed in Section~\ref{sect:twoguidingquestions}, we can uniformly recover this type-dependency using the computational $\Sigma$-type. A similar restriction on type-dependency also appears in the rules for computational pattern-matching; this type-dependency can be recovered analogously to the case of sequential composition. These restrictions on type-dependency enable us to give eMLTT a denotational semantics using a natural fibrational generalisation of the adjunction-based semantics of CBPV and EEC---see Chapters~\ref{chap:fibadjmodels} and~\ref{chap:interpretation} for details.



\begin{definition}
\label{def:judgements}
\index{well-formed syntax}
The \emph{well-formed syntax} of eMLTT and its \emph{equational theory} are defined using the following judgement forms:
\[
\begin{array}{l @{\qquad\qquad}l}
\index{context!value --!well-formed --}
\vdash \Gamma & \text{well-formed value context}
\\
\vdash \Gamma_1 = \Gamma_2 & \text{definitionally equal value contexts}
\\
\index{type!value --!well-formed --}
\lj \Gamma A & \text{well-formed value type}
\\
\ljeq \Gamma A B & \text{definitionally equal value types}
\\
\index{type!computation --!well-formed --}
\lj \Gamma \ul{C} & \text{well-formed computation type}
\\
\ljeq \Gamma {\ul{C}} {\ul{D}} & \text{definitionally equal computation types}
\\
\index{term!value --!well-typed --}
\vj \Gamma V A & \text{well-typed value term}
\\
\veq \Gamma V W A & \text{definitionally equal value terms}
\\
\index{term!computation --!well-typed --}
\cj \Gamma M \ul{C} & \text{well-typed computation term}
\\
\ceq \Gamma M N \ul{C} & \text{definitionally equal computation terms}
\\
\index{term!homomorphism --!well-typed --}
\hj \Gamma {z \!:\! \ul{C}} K \ul{D} & \text{well-typed homomorphism term}
\\
\heq \Gamma {z \!:\! \ul{C}} K L \ul{D} & \text{definitionally equal homomorphism terms}
\end{array}
\]
\end{definition}
\vspace{0.2cm}

\noindent 
These judgements are defined mutually inductively, using the rules given below.
We have organised these rules so that closely-related rules for different judgements are grouped together. For example, we group the formation rule for the type of natural numbers together with the corresponding typing rules and definitional equations.

\paragraph*{Well-formed value contexts} \mbox{}

\noindent
Formation rules for value contexts:
\vspace{0.15cm}
\[
\mkrule
{\vdash \diamond}
{}
\qquad
\mkrule
{\vdash \Gamma, x \!:\! A}
{\vdash \Gamma \quad \lj \Gamma A \quad x \not\in V\!ars(\Gamma)}
\]

\noindent
Rules for definitionally equal value contexts:
\vspace{0.15cm}
\[
\mkrule
{\ljeq {} \diamond \diamond}
{}
\qquad
\mkrule
{\ljeq {} {\Gamma_1, x \!:\! A} {\Gamma_2, x \!:\! B}}
{\ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {\Gamma_1} A B \quad x \not\in V\!ars(\Gamma_1) \quad x \not\in V\!ars(\Gamma_2)}
\]

\paragraph*{Context and type conversions} \mbox{}

\noindent
Context conversion rules for types:
\vspace{0.15cm}
\[
\begin{array}{c}
\mkrule
{\lj {\Gamma_2} A}
{\lj {\Gamma_1} A \quad \ljeq {} {\Gamma_1} {\Gamma_2}}
\qquad
\mkrule
{\lj {\Gamma_2} {\ul{C}}}
{\lj {\Gamma_1} {\ul{C}} \quad \ljeq {} {\Gamma_1} {\Gamma_2}}
\\[6mm]
\mkrule
{\ljeq {\Gamma_2} A B}
{\ljeq {\Gamma_1} A B \quad \ljeq {} {\Gamma_1} {\Gamma_2}}
\qquad
\mkrule
{\ljeq {\Gamma_2} {\ul{C}} {\ul{D}}}
{\ljeq {\Gamma_1} {\ul{C}} {\ul{D}} \quad \ljeq {} {\Gamma_1} {\Gamma_2}}
\end{array}
\]

\noindent
Context and type conversion rules for terms:
\vspace{0.15cm}
\[
\begin{array}{c}
\mkrule
{\vj {\Gamma_2} V B}
{\vj {\Gamma_1} V A \quad \ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {\Gamma_1} A B}
\qquad
\mkrule
{\cj {\Gamma_2} M {\ul{D}}}
{\cj {\Gamma_1} M {\ul{C}} \quad \ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {\Gamma_1} {\ul{C}} {\ul{D}}}
\\[6mm]
\mkrule
{\hj {\Gamma_2} {z \!:\! \ul{C}_2} K {\ul{D}_2}}
{\hj {\Gamma_1} {z \!:\! \ul{C}_1} K {\ul{D}_1} \quad \ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {\Gamma_1} {\ul{C}_1} {\ul{C}_2} \quad \ljeq {\Gamma_1} {\ul{D}_1} {\ul{D}_2}}
\\[6mm]
\mkrule
{\veq {\Gamma_2} V W B}
{\veq {\Gamma_1} V W A \quad \ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {\Gamma_1} A B}
\\[6mm]
\mkrule
{\ceq {\Gamma_2} M N {\ul{D}}}
{\ceq {\Gamma_1} M N {\ul{C}} \quad \ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {\Gamma_1} {\ul{C}} {\ul{D}}}
\\[6mm]
\mkrule
{\heq {\Gamma_2} {z \!:\! \ul{C}_2} K L {\ul{D}_2}}
{\heq {\Gamma_1} {z \!:\! \ul{C}_1} K L {\ul{D}_1} \quad \ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {\Gamma_1} {\ul{C}_1} {\ul{C}_2} \quad \ljeq {\Gamma_1} {\ul{D}_1} {\ul{D}_2}}
\end{array}
\]

\paragraph*{Reflexivity, symmetry and transitivity} \mbox{}

\noindent
Rules for reflexivity:
\vspace{0.15cm}
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma A A}
{\lj \Gamma A}
\qquad
\mkrule
{\ljeq \Gamma {\ul{C}} {\ul{C}}}
{\lj \Gamma {\ul{C}}}
\\[6mm]
\mkrule
{\veq \Gamma V V A}
{\vj \Gamma V A}
\qquad
\mkrule
{\ceq \Gamma M M {\ul{C}}}
{\cj \Gamma M {\ul{C}}}
\qquad
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} K K {\ul{D}}}
{\hj \Gamma {z \!:\! \ul{C}} K {\ul{D}}}
\end{array}
\]

\noindent
Rules for symmetry:
\vspace{0.15cm}
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma A B}
{\ljeq \Gamma B A}
\qquad
\mkrule
{\ljeq \Gamma {\ul{C}} {\ul{D}}}
{\ljeq \Gamma {\ul{D}} {\ul{C}}}
\\[6mm]
\mkrule
{\veq \Gamma V W A}
{\veq \Gamma W V A}
\qquad
\mkrule
{\ceq \Gamma M N {\ul{C}}}
{\ceq \Gamma N M {\ul{C}}}
\qquad
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} K L {\ul{D}}}
{\heq \Gamma {z \!:\! \ul{C}} L K {\ul{D}}}
\end{array}
\]

\noindent
Rules for transitivity:
\vspace{0.15cm}
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {A_1} {A_3}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq \Gamma {A_2} {A_3}}
\qquad
\mkrule
{\ljeq \Gamma {\ul{C}_1} {\ul{C}_3}}
{\ljeq \Gamma {\ul{C}_1} {\ul{C}_2} \quad \ljeq \Gamma {\ul{C}_2} {\ul{C}_3}}
\\[6mm]
\mkrule
{\veq \Gamma {V_1} {V_3} A}
{\veq \Gamma {V_1} {V_2} A \quad \veq \Gamma {V_2} {V_3} A}
\qquad
\mkrule
{\ceq \Gamma {M_1} {M_3} {\ul{C}}}
{\ceq \Gamma {M_1} {M_2} {\ul{C}} \quad \ceq \Gamma {M_2} {M_3} {\ul{C}}}
\\[6mm]
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {K_1} {K_3} {\ul{D}}}
{\heq \Gamma {z \!:\! \ul{C}} {K_1} {K_2} {\ul{D}} \quad \heq \Gamma {z \!:\! \ul{C}} {K_2} {K_3} {\ul{D}}}
\end{array}
\]

\paragraph*{Replacement} \mbox{}

\noindent
Replacement rules for value and computation types:
\vspace{0.25cm}
\[
\begin{array}{c}
\mkrule
{\ljeq {\Gamma_1, \Gamma_2[V_1/x]} {B[V_1/x]} {B[V_2/x]}}
{\lj {\Gamma_1, x \!:\! A, \Gamma_2} B \quad \veq {\Gamma_1} {V_1} {V_2} A}
\qquad
\mkrule
{\ljeq {\Gamma_1, \Gamma_2[V_1/x]} {\ul{C}[V_1/x]} {\ul{C}[V_2/x]}}
{\lj {\Gamma_1, x \!:\! A, \Gamma_2} \ul{C} \quad \veq {\Gamma_1} {V_1} {V_2} A}
\end{array}
\]

\vspace{0.25cm}
\noindent
Replacement rules for value, computation, and homomorphism terms:
\vspace{0.25cm}
\[
\begin{array}{c}
\mkrule
{\veq {\Gamma_1, \Gamma_2[V_1/x]} {W[V_1/x]} {W[V_2/x]} {B[V_1/x]}}
{\vj {\Gamma_1, x \!:\! A, \Gamma_2} W B \quad \veq {\Gamma_1} {V_1} {V_2} A}
\\[6mm]
\mkrule
{\ceq {\Gamma_1, \Gamma_2[V_1/x]} {M[V_1/x]} {M[V_2/x]} {\ul{C}[V_1/x]}}
{\cj {\Gamma_1, x \!:\! A, \Gamma_2} M {\ul{C}} \quad \veq {\Gamma_1} {V_1} {V_2} A}
\\[6mm]
\mkrule
{\heq {\Gamma_1, \Gamma_2[V_1/x]} {z \!:\! \ul{C}[V_1/x]} {K[V_1/x]} {K[V_2/x]} {\ul{D}[V_1/x]}}
{\hj {\Gamma_1, x \!:\! A, \Gamma_2} {z \!:\! \ul{C}} K {\ul{D}} \quad \veq {\Gamma_1} {V_1} {V_2} A}
\\[6mm]
\mkrule
{\ceq {\Gamma} {K[M/z]} {K[N/z]} {\ul{D}}}
{\hj {\Gamma} {z \!:\! \ul{C}} K {\ul{D}} \quad \ceq {\Gamma} {M} {N} {\ul{C}}}
\\[6mm]
\mkrule
{\heq {\Gamma} {z_2 \!:\! \ul{C}} {K[L_1/z_1]} {K[L_2/z_1]} {\ul{D}_2}}
{\hj {\Gamma} {z_1 \!:\! \ul{D}_1} K {\ul{D}_2} \quad \heq {\Gamma} {z_2 \!:\! \ul{C}} {L_1} {L_2} {\ul{D}_1}}
\end{array}
\]

\paragraph*{Variables} \mbox{}

\noindent
Typing rules for value and computation variables:
\[
\mkrule
{\vj {\Gamma_1, x \!:\! A, \Gamma_2} x A}
{\lj {} {\Gamma_1, x \!:\! A, \Gamma_2}}
\qquad
\mkrule
{\hj {\Gamma} {z \!:\! \ul{C}} {z} {\ul{C}}}
{
\lj \Gamma {\ul{C}}
}
\]

\paragraph*{Natural numbers} \mbox{}

\noindent
Formation rule for the type of natural numbers:
\[
\mkrule
{\lj \Gamma {\Nat}}
{\vdash \Gamma}
\]

\noindent
Typing rules for zero, successor, and primitive recursion:
\[
\begin{array}{c}
\mkrule
{\vj \Gamma {\zero} {\Nat}}
{\vdash \Gamma}
\qquad
\mkrule
{\vj \Gamma {\suc V} {\Nat}}
{\vj \Gamma V \Nat}
\\[5mm]
\mkrule
{\vj \Gamma {\natrec {x.\,A} {V_z} {y_1.\,y_2.\,V_s} {V}} {A[V/x]}}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! \Nat} A \quad \vj \Gamma V \Nat 
\\[-1mm]
\vj \Gamma {V_z} {A[\zero/x]} \quad \vj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! A[y_1/x]} {V_s} {A[\suc y_1/x]}
\end{array}
}
\end{array}
\]

\noindent
Congruence rules for successor and primitive recursion:
\[
\begin{array}{c}
\mkrule
{\veq \Gamma {\suc V} {\suc W} {\Nat}}
{\veq \Gamma V W {\Nat}}
\\[5mm]
\mkrule
{\veq \Gamma {\natrec {x.\,A} {V_z} {y_1.\,y_2.\,V_s} {V}} {\natrec {x.\,B} {W_z} {y_1.\,y_2.\,W_s} {W}} {A[V/x]}}
{
\begin{array}{c}
\ljeq {\Gamma, x \!:\! \Nat} {A} {B}
\quad
\veq \Gamma V W {\Nat}
\\[-1mm]
\veq \Gamma {V_z} {W_z} {A[\zero/x]}
\quad
\veq {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! A[y_1/x]} {V_s} {W_s} {A[\suc y_1/x]}
\end{array}
}
\end{array}
\]

\noindent
$\beta$-equations for primitive recursion:
\[
\begin{array}{c}
\mkrule
{\veq \Gamma {\natrec {x.\,A} {V_z} {y_1.\,y_2.\,V_s} {\zero}} {V_z} {A[\zero/x]}}
{\lj {\Gamma, x \!:\! \Nat} A \quad \vj \Gamma {V_z} {A[\zero/x]} \quad \vj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! A[y_1/x]} {V_s} {A[\suc y_1/x]}}
\\[5mm]
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\natrec {x.\,A} {V_z} {y_1.\,y_2.\,V_s} {\suc V}} 
\\[-1mm]
& = & {V_s[V/y_1][\natrec {x.A} {V_z} {y_1.\,y_2.\,V_s} {V}/y_2]} : {A[\suc V/x]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! \Nat} A \quad \vj \Gamma V \Nat 
\\[-1mm]
\vj \Gamma {V_z} {A[\zero/x]} \quad \vj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! A[y_1/x]} {V_s} {A[\suc y_1/x]}
\end{array}
}
\end{array}
\]

\paragraph*{Unit type} \mbox{}

\noindent
Formation rule for the unit type:
\[
\mkrule
{\lj \Gamma 1}
{\vdash \Gamma}
\]

\noindent
Typing rule for the unit:
\[
\mkrule
{\vj \Gamma \star 1}
{\vdash \Gamma}
\]

\noindent
$\eta$-equation for the unit:
\[
\mkrule
{\veq \Gamma V \star 1}
{\vj \Gamma V 1}
\] 

\paragraph*{Value $\Sigma$-type} \mbox{}

\noindent
Formation rule for the value $\Sigma$-type:
\[
\mkrule
{\lj \Gamma {\Sigma \, x \!:\! A .\, B}}
{\lj {\Gamma, x \!:\! A} B}
\]

\noindent
Typing rules for pairing and pattern-matching:
\[
\begin{array}{c}
\mkrule
{\vj \Gamma {\langle V , W \rangle_{(x : A).\,B}} {\Sigma \, x \!:\! A .\, B}}
{\vj \Gamma V A \quad \lj {\Gamma, x \!:\! A} B \quad \vj \Gamma W {B[V/x]}}
\\[5mm]
\mkrule
{\vj \Gamma {\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\,B} W} {B[V/y]}}
{
\begin{array}{c}
\lj {\Gamma, y \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} B 
\\[-1mm]
\vj \Gamma V {\Sigma \, x_1 \!:\! A_1 .\, A_2} \quad \vj {\Gamma, x_1 \!:\! A_1, x_2 \!:\! A_2} {W} {B[\langle x_1 , x_2 \rangle_{(x_1 : A_1).\,A_2} /y]}
\end{array}
}
\end{array}
\]

\noindent
Congruence rules for the value $\Sigma$-type, pairing, and pattern-matching:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {\Sigma \, x \!:\! A_1 .\, B_1} {\Sigma \, x \!:\! A_2 .\, B_2}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {B_1} {B_2}}
\\[6mm]
\mkrule
{\veq \Gamma {\langle V_1 , W_1 \rangle_{(x : A_1).\, B_1}} {\langle V_2 , W_2 \rangle_{(x : A_2).\, B_2}} {\Sigma \, x \!:\! A_1 . B_1}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {B_1} {B_2} \quad \veq \Gamma {V_1} {V_2} {A_1} \quad \veq \Gamma {W_1} {W_2} {B_1[V_1/x]}}
\\[5mm]
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\pmatch {V_1} {(x_1 \!:\! A_{11}, x_2 \!:\! A_{21})} {y.\, B_1} {W_1}} 
\\[-1mm]
& = & {\pmatch {V_2} {(x_1 \!:\! A_{12}, x_2 \!:\! A_{22})} {y.\, B_2} {W_2}} : {B_1[V_1/y]}
\end{array}
}
{
\begin{array}{c}
\ljeq \Gamma {A_{11}} {A_{12}} \quad \ljeq {\Gamma, x_1 \!:\! A_{11}} {A_{21}} {A_{22}} \quad \ljeq {\Gamma, y \!:\! \Sigma \, x_1 \!:\! A_{11} .\, A_{21}} {B_1} {B_2} 
\\[-1mm]
\veq \Gamma {V_1} {V_2} {\Sigma \, x_1 \!:\! A_{11} .\, A_{21}} \quad \veq {\Gamma, x_1 \!:\! A_{11}, x_2 \!:\! A_{21}} {W_1} {W_2} {B_1[\langle x_1 , x_2 \rangle_{(x_1 : A_{11}).\,A_{21}} /y]}
\end{array}
}
\end{array}
\]

\noindent
$\beta$- and $\eta$-equations  for pattern-matching:
\[
\begin{array}{c}
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\pmatch {\langle V_1 , V_2 \rangle_{(x_1 : A_1).\,A_2}} {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\,B} W} 
\\
& = & {W[V_1/x_1][V_2/x_2]} : {B[\langle V_1 , V_2 \rangle_{(x_1 : A_1).\,A_2}/y]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} B
\quad
\vj \Gamma {V_1} {A_1} \quad \vj \Gamma {V_2} {A_2[V_1/x_1]}
\\[-1mm]
\vj {\Gamma, x_1 \!:\! A_1, x_2 \!:\! A_2} {W} {B[\langle x_1 , x_2 \rangle_{(x_1 : A_1).\,A_2} /y]}
\end{array}
}
\\[9mm]
\mkrule
{\veq \Gamma {\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y_1.\,B} {W[{\langle x_1 , x_2 \rangle_{(x_1 : A_1).\,A_2}}/y_2]}} {W[V/y_2]} {B[V/y_1]}}
{
\begin{array}{c}
\lj \Gamma {A_1} \quad \lj {\Gamma, x_1 \!:\! A_1} {A_2}
\quad
\vj \Gamma V {\Sigma \, x_1 \!:\! A_1 .\, A_2}  
\\[-1mm]
\lj {\Gamma, y_1 \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} B \quad \vj {\Gamma, y_2 \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} {W} {B[y_2/y_1]}
\end{array}
}
\end{array}
\]

\paragraph*{Value $\Pi$-type} \mbox{}

\noindent
Formation rule for the value $\Pi$-type:
\[
\mkrule
{\lj \Gamma {\Pi \, x \!:\! A .\, B}}
{\lj {\Gamma, x \!:\! A} B}
\]

\noindent
Typing rules for lambda abstraction and function application:
\[
\mkrule
{\vj \Gamma {\lambda \, x \!:\! A .\, V} {\Pi \, x \!:\! A .\, B}}
{\vj {\Gamma, x \!:\! A} V B}
\qquad
\mkrule
{\vj \Gamma {V(W)_{(x : A).\, B}} {B[W/x]}}
{\lj {\Gamma, x \!:\! A} {B} \quad \vj \Gamma V {\Pi \, x \!:\! A .\, B} \quad \vj \Gamma W A}
\]

\noindent
Congruence rules for the value $\Pi$-type, lambda abstraction, and function application:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {\Pi \, x \!:\! A_1 .\, B_1} {\Pi \, x \!:\! A_2 .\, B_2}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {B_1} {B_2}}
\\[6mm]
\mkrule
{\veq \Gamma {\lambda \, x \!:\! A_1 .\, V_1} {\lambda \, x \!:\! A_2 .\, V_2} {\Pi \, x \!:\! A_1 .\, B}}
{\ljeq \Gamma {A_1} {A_2} \quad \veq {\Gamma, x \!:\! A_1} {V_1} {V_2} B}
\\[6mm]
\mkrule
{\veq \Gamma {V_1(W_1)_{(x : A_1).\, B_1}} {V_2(W_2)_{(x : A_2).\, B_2}} {B_1[W_1/x]}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {B_1} {B_2} \quad \veq \Gamma {V_1} {V_2} {\Pi \, x \!:\! A_1 .\, B_1} \quad \veq {\Gamma} {W_1} {W_2} {A_1}}
\end{array}
\]

\noindent
$\beta$- and $\eta$-equations for lambda abstraction and function application:
\[
\begin{array}{c}
\mkrule
{\veq \Gamma {(\lambda \, x \!:\! A .\, V)(W)_{(x : A) .\, B}} {V[W/x]} {B[W/x]}}
{\vj {\Gamma, x \!:\! A} V B \quad \vj \Gamma W A}
\\[6mm]
\mkrule
{\veq \Gamma {V} {\lambda \, x \!:\! A .\, V(x)_{(x : A) .\, B}} {\Pi \, x \!:\! A .\, B}}
{\lj {\Gamma, x \!:\! A} {B} \quad \vj \Gamma V {\Pi \, x \!:\! A .\, B}}
\end{array}
\]


\paragraph*{Empty type} \mbox{}

\noindent
Formation rule for the empty type:
\[
\mkrule
{\lj \Gamma 0}
{\vdash \Gamma}
\]

\noindent
Typing rule for empty case analysis:
\[
\mkrule
{\vj \Gamma {\absurd {x.\, A} V} {A[V/x]}}
{\lj {\Gamma, x \!:\! 0} A \quad \vj \Gamma V 0}
\]

\noindent
Congruence rule for empty case analysis:
\[
\mkrule
{\veq \Gamma {\absurd {x.\, A_1} {V_1}} {\absurd {x.\, A_2} {V_2}} {A_1[V_1/x]}}
{\ljeq {\Gamma, x \!:\! 0} {A_1} {A_2} \quad \veq \Gamma {V_1} {V_2} 0}
\]

\noindent
$\eta$-equation for empty case analysis:
\[
\mkrule
{\veq \Gamma {\absurd {x.\, A} V} {W[V/x]} {A[V/x]}}
{\lj {\Gamma, x \!:\! 0} A \quad \vj \Gamma V 0 \quad \vj {\Gamma, x \!:\! 0} W A}
\]


\paragraph*{Coproduct type} \mbox{}

\noindent
Formation rule for the coproduct type:
\[
\mkrule
{\lj \Gamma {A + B}}
{\lj \Gamma A \quad \lj \Gamma B}
\]

\noindent
Typing rules for the left and right injections, and binary case analysis:
\[
\begin{array}{c}
\mkrule
{\vj \Gamma {\inl {A + B} V} {A + B}}
{\vj \Gamma V A}
\qquad
\mkrule
{\vj \Gamma {\inr {A + B} V} {A + B}}
{\vj \Gamma V B}
\\[5mm]
\mkrule
{\vj \Gamma {\case {V} {x.\, B} {\inl {\!} {\!\!(y_1 \!:\! A_1)} \mapsto W_1} {\inr {\!} {\!\!(y_2 \!:\! A_2)} \mapsto W_2}} {B[V/x]}}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! A_1 + A_2} B \quad \vj \Gamma V {A_1 + A_2} 
\\[-1mm]
\vj {\Gamma, y_1 \!:\! A_1} {W_1} {B[\inl {A_1 + A_2} y_1/x]} \quad \vj {\Gamma, y_2 \!:\! A_2} {W_2} {B[\inr {A_1 + A_2} y_2/x]}
\end{array}
}
\end{array}
\]

\noindent
Congruence rules for the coproduct type, left and right injections, and binary case analysis:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {A_1 + B_1} {A_2 + B_2}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq \Gamma {B_1} {B_2}}
\\[6mm]
\mkrule
{\veq \Gamma {\inl {A_1 + B_1} {V_1}} {\inl {A_2 + B_2} {V_2}} {A_1 + B_1}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq \Gamma {B_1} {B_2} \quad \veq \Gamma {V_1} {V_2} {A_1}}
\\[6.5mm]
\mkrule
{\veq \Gamma {\inr {A_1 + B_1} {V_1}} {\inr {A_2 + B_2} {V_2}} {A_1 + B_1}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq \Gamma {B_1} {B_2} \quad \veq \Gamma {V_1} {V_2} {B_1}}
\\[5mm]
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\case {V_1} {x.\, B_1} {\inl {\!} {\!\!(y_1 \!:\! A_{11})} \mapsto W_{11}} {\inr {\!} {\!\!(y_2 \!:\! A_{21})} \mapsto W_{21}}}
\\ 
& = & {\case {V_2} {x.\, B_2} {\inl {\!} {\!\!(y_1 \!:\! A_{12})} \mapsto W_{12}} {\inr {\!} {\!\!(y_2 \!:\! A_{22})} \mapsto W_{22}}} : {B_1[V_1/x]}
\end{array}
}
{
\begin{array}{c}
\ljeq \Gamma {A_{11}} {A_{12}} \quad \ljeq \Gamma {A_{21}} {A_{22}} \quad \ljeq {\Gamma, x \!:\! A_{11} + A_{21}} {B_1} {B_2} 
\\[-1mm]
\veq \Gamma {V_1} {V_2} {A_{11} + A_{21}}  \quad \veq {\Gamma, y_1 \!:\! A_{11}} {W_{11}} {W_{12}} {B_1[\inl {A_{11} + A_{21}} y_1/x]} 
\\[-1mm]
\veq {\Gamma, y_2 \!:\! A_{12}} {W_{21}} {W_{22}} {B_1[\inr {A_{12} + A_{22}} y_2/x]} 
\end{array}
}
\end{array}
\]

\noindent
$\beta$- and $\eta$-equations for binary case analysis:
\[
\begin{array}{c}
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\case {(\inl {A_1 + A_2} V)} {x.\, B} {\inl {\!} {\!\!(y_1 \!:\! A_1)} \mapsto W_1} {\inr {\!} {\!\!(y_2 \!:\! A_2)} \mapsto W_2}} 
\\
& = & {W_1[V/y_1]} : {B[\inl {A_1 + A_2} V/x]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! A_1 + A_2} B \quad \vj \Gamma V {A_1} 
\\
\vj {\Gamma, y_1 \!:\! A_1} {W_1} {B[\inl {A_1 + A_2} y_1/x]} \quad \vj {\Gamma, y_2 \!:\! A_2} {W_2} {B[\inr {A_1 + A_2} y_2/x]}
\end{array}
}
\\[9mm]
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\case {(\inr {A_1 + A_2} V)} {x.\, B} {\inl {\!} {\!\!(y_1 \!:\! A_1)} \mapsto W_1} {\inr {\!} {\!\!(y_2 \!:\! A_2)} \mapsto W_2}} 
\\
& = & {W_2[V/y_2]} : {B[\inr {A_1 + A_2} V/x]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! A_1 + A_2} B \quad \vj \Gamma V {A_2} 
\\[-1mm]
\vj {\Gamma, y_1 \!:\! A_1} {W_1} {B[\inl {A_1 + A_2} y_1/x]} \quad \vj {\Gamma, y_2 \!:\! A_2} {W_2} {B[\inr {A_1 + A_2} y_2/x]}
\end{array}
}
\\[9mm]
\mkrule
{
\begin{array}{c}
\hspace{-3.7cm} \Gamma \vdash {\mathtt{case~} V \mathtt{~of}_{x_1.\,B} \mathtt{~} ({\inl {\!} {\!\!(y_1 \!:\! A_1)} \mapsto W[\inl {A_1 + A_2} y_1/x_2]} , }
\\[-1mm]
\hspace{3.35cm} {\inr {\!} {\!\!(y_2 \!:\! A_2)} \mapsto W[\inr {A_1 + A_2} y_2/x_2]}) = {W[V/x_2]} : {B[V/x_1]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, x_1 \!:\! A_1 + A_2} B
\quad
\vj \Gamma V {A_1 + A_2} \quad \vj {\Gamma, x_2 \!:\! A_1 + A_2} {W} {B[x_2/x_1]}
\end{array} 
}
\end{array}
\]

\paragraph*{Propositional equality} \mbox{}

\noindent
Formation rule for propositional equality:
\[
\mkrule
{\lj \Gamma {V =_A W}}
{\vj \Gamma V A \quad \vj \Gamma W A}
\]

\noindent
Typing rules for the introduction and elimination forms of propositional equality:
\[
\begin{array}{c}
\mkrule
{\vj \Gamma {\refl A V} {V =_A V}}
{\vj \Gamma V A}
\\[3mm]
\mkrule
{\vj \Gamma {\pathind A {x_1.\, x_2.\, x_3.\, B} {y.\, W} {V_1} {V_2} {V_p}} {B[V_1/x_1][V_2/x_2][V_p/x_3]}}
{
\begin{array}{c}
\lj \Gamma A \quad \lj {\Gamma, x_1 \!:\! A, x_2 \!:\! A, x_3 \!:\! x_1 =_A x_2} {B} \quad \vj \Gamma {V_1} A \quad \vj \Gamma {V_2} A 
\\[-1mm]
\vj \Gamma {V_p} {V_1 =_A V_2} \quad \vj {\Gamma, y \!:\! A} {W} {B[y/x_1][y/x_2][\refl A y/x_3]}
\end{array}
}
\end{array}
\]

\noindent
Congruence rules for propositional equality, and its introduction and elimination forms:
\vspace{0.1cm}
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {(V_1 =_{A_1} {W_1})} {(V_2 =_{A_2} {W_2})}}
{\ljeq \Gamma {A_1} {A_2} \quad \veq \Gamma {V_1} {V_2} {A_1} \quad \veq \Gamma {W_1} {W_2} {A_1}}
\\[6mm]
\mkrule
{\veq \Gamma {\refl {A_1} {V_1}} {\refl {A_2} {V_2}} {V_1 =_{A} {V_1}}}
{\veq \Gamma {V_1} {V_2} {A}}
\\[4mm]
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\pathind {A_1} {x_1.\, x_2.\, x_3.\, B_1} {y.\, W_1} {V_{11}} {V_{21}} {V_{p1}}} 
\\
& = & {\pathind {A_2} {x_1.\, x_2.\, x_3.\, B_2} {y.\, W_2} {V_{12}} {V_{22}} {V_{p2}}} : {B_1[V_{11}/x_1][V_{21}/x_2][V_{p1}/x_3]}
\end{array}
}
{
\begin{array}{c}
\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x_1 \!:\! A_1, x_2 \!:\! A_1, x_3 \!:\! x_1 =_{A_1} x_2} {B_1} {B_2} 
\\[-1mm]
\veq \Gamma {V_{11}} {V_{12}} {A_1} \quad \veq \Gamma {V_{21}} {V_{22}} {A_1} \quad \veq \Gamma {V_{p1}} {V_{p2}} {V_{11} =_{A_1} V_{21}} 
\\[-1mm]
\veq {\Gamma, y \!:\! A_1} {W_1} {W_2} {B_1[y/x_1][y/x_2][\refl {A_1} y/x_3]}
\end{array}
}
\end{array}
\]

\noindent
$\beta$-equation for the elimination form of propositional equality:
\vspace{-0.1cm}
\[
\mkrule
{\veq \Gamma {\pathind A {x_1.\, x_2.\, x_3.\, B} {y.\, W} {V} {V} {\refl A V}} {W[V/y]} {B[V/x_1][V/x_2][\refl A V/x_3]}}
{
\begin{array}{c}
\lj \Gamma A \quad \lj {\Gamma, x_1 \!:\! A, x_2 \!:\! A, x_3 \!:\! x_1 =_A x_2} {B}
\\[-1mm]
\vj \Gamma {V} A \quad \vj {\Gamma, y \!:\! A} {W} {B[y/x_1][y/x_2][\refl A y/x_3]}
\end{array}
}
\]

\paragraph*{Thunked computations} \mbox{}

\noindent
Formation rule for the type of thunked computations:
\[
\mkrule
{\lj \Gamma {U\ul{C}}}
{\lj \Gamma {\ul{C}}}
\]

\noindent
Typing rules for thunking and forcing:
\[
\mkrule
{\vj \Gamma {\thunk M} {U\ul{C}}}
{\cj \Gamma M {\ul{C}}}
\qquad
\mkrule
{\cj \Gamma {\force {\ul{C}} V} {\ul{C}}}
{\vj \Gamma V {U\ul{C}}}
\]

\noindent
Congruence rules for the type of thunked computations, thunking, and forcing:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {U\ul{C}_1} {U\ul{C}_2}}
{\ljeq \Gamma {\ul{C}_1} {\ul{C}_2}}
\\[6mm]
\mkrule
{\veq \Gamma {\thunk M_1} {\thunk M_2} {U\ul{C}}}
{\ceq \Gamma {M_1} {M_2} \ul{C}}
\\[6mm]
\mkrule
{\ceq \Gamma {\force {\ul{C}_1} {V_1}} {\force {\ul{C}_2} V_2} {\ul{C}_1}}
{\ljeq \Gamma {\ul{C}_1} {\ul{C}_2} \quad \veq \Gamma {V_1} {V_2} {U\ul{C}_1}}
\end{array}
\]

\noindent
Equations relating thunking and forcing:
\[
\begin{array}{c}
\mkrule
{\veq \Gamma {\thunk (\force {\ul{C}} V)} {V} {U\ul{C}}}
{\vj \Gamma V {U\ul{C}}}
\qquad
\mkrule
{\ceq \Gamma {\force {\ul{C}} {(\thunk M)}} {M} {\ul{C}}}
{\cj \Gamma M {\ul{C}}}
\end{array}
\]

\paragraph*{Homomorphic function type} \mbox{}

\noindent
Formation rule for the homomorphic function type:
\[
\mkrule
{\lj \Gamma {\ul{C} \multimap \ul{D}}}
{\lj \Gamma {\ul{C}} \quad \lj \Gamma {\ul{D}}}
\]

\noindent
Typing rules for the homomorphic lambda abstraction and function application:
\[
\begin{array}{c}
\mkrule
{\vj \Gamma {\lambda \, z \!:\! \ul{C} .\, K} {\ul{C} \multimap \ul{D}}}
{\hj \Gamma {z \!:\! \ul{C}} K {\ul{D}}}
\\[6mm]
\mkrule
{\cj \Gamma {V(M)_{\ul{C}, \ul{D}}} {\ul{D}}}
{\vj \Gamma V {\ul{C} \multimap \ul{D}} \quad \cj \Gamma M \ul{C}}
\qquad
\mkrule
{\hj \Gamma {z \!:\! \ul{C}} {V(K)_{\ul{D}_1, \ul{D}_2}} {\ul{D}_2}}
{\vj \Gamma V {\ul{D}_1 \multimap \ul{D}_2} \quad \hj \Gamma {z \!:\! \ul{C}} K {\ul{D}_1}}
\vspace{0.1cm}
\end{array}
\]

\noindent
Congruence rules for the homomorphic function type, lambda abstraction, and function application:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {\ul{C}_1 \multimap \ul{D}_1} {\ul{C}_2 \multimap \ul{D}_2}}
{\ljeq \Gamma {\ul{C}_1} {\ul{C}_2} \quad \ljeq \Gamma {\ul{D}_1} {\ul{D}_2}}
\\[6mm]
\mkrule
{\veq \Gamma {\lambda \, z \!:\! \ul{C}_1 .\, K_1} {\lambda \, z \!:\! \ul{C}_2 .\, K_2} {\ul{C}_1 \multimap \ul{D}}}
{\ljeq {\Gamma} {\ul{C}_1} {\ul{C}_2} \quad \heq \Gamma {z \!:\! \ul{C}_1} {K_1} {K_2} {\ul{D}}}
\\[6mm]
\mkrule
{\ceq \Gamma {V_1(M_1)_{\ul{C}_1, \ul{D}_1}} {V_2(M_2)_{\ul{C}_2, \ul{D}_2}} {\ul{D}_1}}
{\ljeq {\Gamma} {\ul{C}_1} {\ul{C}_2} \quad \ljeq {\Gamma} {\ul{D}_1} {\ul{D}_2} \quad \veq \Gamma {V_1} {V_2} {\ul{C}_1 \multimap \ul{D}_1} \quad \ceq \Gamma {M_1} {M_2} {\ul{C}_1}}
\\[6mm]
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {V_1(K_1)_{\ul{D}_{11}, \ul{D}_{21}}} {V_2(K_2)_{\ul{D}_{12}, \ul{D}_{22}}} {\ul{D}_{21}}}
{\ljeq {\Gamma} {\ul{D}_{11}} {\ul{D}_{12}} \quad \ljeq {\Gamma} {\ul{D}_{21}} {\ul{D}_{22}} \quad \veq \Gamma {V_1} {V_2} {\ul{D}_{11} \multimap \ul{D}_{21}} \quad \heq \Gamma {z \!:\! \ul{C}} {K_1} {K_2} {\ul{D}_{11}}}
\end{array}
\]

\noindent
$\beta$- and $\eta$-equations for homomorphic lambda abstraction and function application:
\[
\begin{array}{c}
\mkrule
{\ceq \Gamma {(\lambda \, z \!:\! \ul{C} .\, K)(M)_{\ul{C}, \ul{D}}} {K[M/z]} {\ul{D}}}
{\cj \Gamma M \ul{C} \quad \hj \Gamma {z \!:\! \ul{C}} K {\ul{D}}}
\\[6mm]
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {(\lambda \, z_2 \!:\! \ul{D}_1 .\, L)(K)_{\ul{D}_1, \ul{D}_2}} {L[K/z_2]} {\ul{D}_2}}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\ul{D}_1} \quad \hj \Gamma {z_2 \!:\! \ul{D}_1} L {\ul{D}_2}}
\\[6mm]
\mkrule
{\veq \Gamma V {\lambda\, z \!:\! \ul{C} .\, V(z)_{\ul{C}, \ul{D}}} {\ul{C} \multimap \ul{D}}}
{\vj \Gamma V {\ul{C} \multimap \ul{D}}}
\end{array}
\]


\paragraph*{Type of computations that return values of a give value type} \mbox{}

\noindent
Formation rule for the type of computations that return values of a give value type:
\[
\mkrule
{\lj \Gamma {FA}}
{\lj \Gamma A}
\]

\noindent
Typing rules for returning a value and sequential composition:
\[
\begin{array}{c}
\mkrule
{\cj \Gamma {\return V} {FA}}
{\vj \Gamma V A}
\\[6mm]
\mkrule
{\cj \Gamma {\doto M {x \!:\! A} {\ul{C}} N} {\ul{C}}}
{\cj \Gamma M {FA} \quad \lj \Gamma {\ul{C}} \quad \cj {\Gamma, x \!:\! A} {N} {\ul{C}}}
\\[6mm]
\mkrule
{\hj \Gamma {z \!:\! \ul{C}} {\doto K {x \!:\! A} {\ul{D}} M} {\ul{D}}}
{\hj \Gamma {z \!:\! \ul{C}} K {FA} \quad \lj \Gamma {\ul{D}} \quad \cj {\Gamma, x \!:\! A} {M} {\ul{D}}}
\end{array}
\]

\noindent
Congruence rules for the type of computations that return values of a given value type, returning a value,  and sequential composition:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {FA_1} {FA_2}}
{\ljeq \Gamma {A_1} {A_2}}
\\[6mm]
\mkrule
{\ceq \Gamma {\return {V_1}} {\return {V_2}} {FA}}
{\veq \Gamma {V_1} {V_2} A}
\\[6mm]
\mkrule
{\ceq \Gamma {\doto {M_1} {x \!:\! A_1} {\ul{C}_1} {N_1}} {\doto {M_2} {x \!:\! A_2} {\ul{C}_2} {N_2}} {\ul{C}_1}}
{\ljeq \Gamma {A_1} {A_2} \quad \ceq \Gamma {M_1} {M_2} {FA_1} \quad \ljeq \Gamma {\ul{C}_1} {\ul{C}_2} \quad \ceq {\Gamma, x \!:\! A_1} {N_1} {N_2} {\ul{C}_1}}
\\[6mm]
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\doto {K_1} {x \!:\! A_1} {\ul{D}_1} {M_1}} {\doto {K_2} {x \!:\! A_2} {\ul{D}_2} {M_2}} {\ul{D}_1}}
{\ljeq \Gamma {A_1} {A_2} \quad \heq \Gamma {z \!:\! \ul{C}} {K_1} {K_2} {FA_1} \quad \ljeq \Gamma {\ul{D}_1} {\ul{D}_2} \quad \ceq {\Gamma, x \!:\! A_1} {M_1} {M_2} {\ul{D}_1}}
\end{array}
\]

\pagebreak

\noindent
$\beta$- and $\eta$-equations for sequential composition:
\[
\begin{array}{c}
\mkrule
{\ceq \Gamma {\doto {\return V} {x \!:\! A} {\ul{C}} M} {M[V/x]} {\ul{C}}}
{\vj \Gamma V {A} \quad \lj \Gamma {\ul{C}} \quad \cj {\Gamma, x \!:\! A} {M} {\ul{C}}}
\\[6mm]
\mkrule
{\ceq \Gamma {\doto M {x \!:\! A} {\ul{C}} {K[\return x/z]}} {K[M/z]} {\ul{C}}}
{\cj \Gamma M {FA} \quad \lj \Gamma {\ul{C}} \quad \hj {\Gamma} {z \!:\! FA} {K} {\ul{C}}}
\\[6mm]
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto K {x \!:\! A} {\ul{D}} {L[\return x/z_2]}} {L[K/z_2]} {\ul{D}}}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {FA} \quad \lj \Gamma {\ul{D}} \quad \hj {\Gamma} {z_2 \!:\! FA} {L} {\ul{D}}}
\end{array}
\]



\paragraph*{Computational $\Sigma$-type} \mbox{}

\noindent
Formation rule for the computational $\Sigma$-type:
\[
\begin{array}{c}
\mkrule
{\lj \Gamma {\Sigma \, x \!:\! A .\, \ul{C}}}
{\lj {\Gamma, x \!:\! A} {\ul{C}}}
\end{array}
\]

\noindent
Typing rules for computational pairing and pattern-matching: 
\[
\begin{array}{c}
\mkrule
{\cj \Gamma {\langle V , M \rangle_{(x : A).\, \ul{C}}} {\Sigma \, x \!:\! A .\, \ul{C}}}
{\vj \Gamma V A \quad \lj {\Gamma, x \!:\! A} {\ul{C}} \quad \cj \Gamma M {\ul{C}[V/x]}}
\\[6mm]
\mkrule
{\cj \Gamma {\doto M {(x \!:\! A, z \!:\! \ul{C})} {\ul{D}} K} {\ul{D}}}
{\cj \Gamma M {\Sigma \, x \!:\! A .\, \ul{C}} \quad \lj \Gamma {\ul{D}} \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} {K} {\ul{D}}}
\\[6mm]
\mkrule
{\hj \Gamma {z \!:\! \ul{C}} {\langle V , K \rangle_{(x : A).\, \ul{D}}} {\Sigma \, x \!:\! A .\, \ul{D}}}
{\vj \Gamma V A \quad \lj {\Gamma, x \!:\! A} {\ul{D}} \quad \hj \Gamma {z \!:\! \ul{C}} K {\ul{D}[V/x]}}
\\[6mm]
\mkrule
{\hj \Gamma {z_1 \!:\! \ul{C}} {\doto K {(x \!:\! A, z_2 \!:\! \ul{D}_1)} {\ul{D}_2} L} {\ul{D}_2}}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma \, x \!:\! A .\, \ul{D}_1} \quad \lj \Gamma {\ul{D}_2} \quad \hj {\Gamma, x \!:\! A} {z_2 \!:\! \ul{D}_1} {L} {\ul{D}_2}}
\end{array}
\]

\noindent
Congruence rules for the computational $\Sigma$-type, computational pairing, and pattern-matching:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {\Sigma \, x \!:\! A_1 .\, \ul{C}_1} {\Sigma \, x \!:\! A_2 .\, \ul{C}_2}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{C}_1} {\ul{C}_2}}
\\[6mm]
\mkrule
{\ceq \Gamma {\langle V_1 , M_1 \rangle_{(x : A_1).\, \ul{C}_1}} {\langle V_2 , M_2 \rangle_{(x : A_2).\, \ul{C}_2}} {\Sigma \, x \!:\! A_1 . \ul{C}_1}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{C}_1} {\ul{C}_2} \quad \veq \Gamma {V_1} {V_2} {A_1} \quad \ceq \Gamma {M_1} {M_2} {\ul{C}_1[V_1/x]}}
\\[6mm]
\mkrule
{\ceq \Gamma {\doto {M_1} {(x \!:\! A_1, z \!:\! \ul{C}_1)} {\ul{D}_1} {K_1}} {\doto {M_2} {(x \!:\! A_2, z \!:\! \ul{C}_2)} {\ul{D}_2} {K_2}} {\ul{D}_1}}
{
\begin{array}{c}
\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{C}_1} {\ul{C}_2} \quad \ljeq \Gamma {\ul{D}_1} {\ul{D}_2}
\\[-1mm]
\ceq \Gamma {M_1} {M_2} {\Sigma \, x \!:\! A_1 .\, \ul{C}_1} \quad \heq {\Gamma, x \!:\! A_1} {z \!:\! \ul{C}_1} {K_1} {K_2} {\ul{D}_1}
\end{array}
}
\end{array}
\]

\[
\begin{array}{c}
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\langle V_1 , K_1 \rangle_{(x : A_1).\, \ul{D}_1}} {\langle V_2 , K_2 \rangle_{(x : A_2).\, \ul{D}_2}} {\Sigma \, x \!:\! A_1 . \ul{D}_1}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{D}_1} {\ul{D}_2} \quad \veq \Gamma {V_1} {V_2} {A_1} \quad \heq \Gamma {z \!:\! \ul{C}} {K_1} {K_2} {\ul{D}_1[V_1/x]}}
\\[5mm]
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto {K_1} {(x \!:\! A_1, z_2 \!:\! \ul{D}_{11})} {\ul{D}_{21}} {L_1}} {\doto {K_2} {(x \!:\! A_2, z_2 \!:\! \ul{D}_{12})} {\ul{D}_{22}} {L_2}} {\ul{D}_{21}}}
{
\begin{array}{c}
\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{D}_{11}} {\ul{D}_{12}} \quad \ljeq \Gamma {\ul{D}_{21}} {\ul{D}_{22}}
\\[-1mm]
\heq \Gamma {z_1 \!:\! \ul{C}} {K_1} {K_2} {\Sigma \, x \!:\! A_1 .\, \ul{D}_{11}} \quad \heq {\Gamma, x \!:\! A_1} {z_2 \!:\! \ul{D}_{11}} {L_1} {L_2} {\ul{D}_{21}}
\end{array}
}
\end{array}
\]

\noindent
$\beta$- and $\eta$-equations for computational pattern-matching:
\[
\begin{array}{c}
\mkrule
{\ceq \Gamma {\doto {\langle V , M \rangle_{(x : A).\, \ul{C}}} {(x \!:\! A, z \!:\! \ul{C})} {\ul{D}} K} {K[V/x][M/z]} {\ul{D}}}
{\vj \Gamma V A \quad \cj \Gamma M {\ul{C}[V/x]} \quad \lj \Gamma {\ul{D}} \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} {K} {\ul{D}}}
\\[6mm]
\mkrule
{\ceq \Gamma {\doto M {(x \!:\! A, z_1 \!:\! \ul{C})} {\ul{D}} {K[{\langle x , z_1 \rangle_{(x : A).\, \ul{C}}}/z_2]}} {K[M/z_2]} {\ul{D}}}
{\lj {\Gamma, x \!:\! A} {\ul{C}} \quad \cj \Gamma M {\Sigma \, x \!:\! A .\, \ul{C}} \quad \lj \Gamma {\ul{D}} \quad \hj {\Gamma} {z_2 \!:\! \Sigma \, x \!:\! A .\, \ul{C}} {K} {\ul{D}}}
\\[6mm]
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto {\langle V , K \rangle_{(x : A).\, \ul{D}_1}} {(x \!:\! A, z_2 \!:\! \ul{D}_1)} {\ul{D}_2} L} {L[V/x][K/z_2]} {\ul{D}_2}}
{\vj \Gamma V A \quad \hj \Gamma {z_1 \!:\! \ul{C}} K {\ul{D}_1[V/x]} \quad \lj \Gamma {\ul{D}_2} \quad \hj {\Gamma, x \!:\! A} {z_2 \!:\! \ul{D}_1} {L} {\ul{D}_2}}
\\[6mm]
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto K {(x \!:\! A, z_2 \!:\! \ul{D}_1)} {\ul{D}_2} {L[{\langle x , z_2 \rangle_{(x : A).\, \ul{D}_1}}/z_3]}} {L[K/z_3]} {\ul{D}_2}}
{\lj {\Gamma, x \!:\! A} {\ul{D}_1} \quad \hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma \, x \!:\! A .\, \ul{D}_1} \quad \lj \Gamma {\ul{D}_2} \quad \hj {\Gamma} {z_3 \!:\! \Sigma \, x \!:\! A .\, \ul{D}_1} {K} {\ul{D}_2}}
\end{array}
\]

\paragraph*{Computational $\Pi$-type} \mbox{}

\noindent
Formation rule for the computational $\Pi$-type:
\[
\mkrule
{\lj \Gamma {\Pi \, x \!:\! A .\, \ul{C}}}
{\lj {\Gamma, x \!:\! A} \ul{C}}
\]

\noindent
Typing rules for computational lambda abstraction and function application:
\[
\begin{array}{c}
\mkrule
{\cj \Gamma {\lambda \, x \!:\! A .\, M} {\Pi \, x \!:\! A .\, \ul{C}}}
{\cj {\Gamma, x \!:\! A} M \ul{C}}
\qquad
\mkrule
{\cj \Gamma {M(V)_{(x : A).\, \ul{C}}} {\ul{C}[V/x]}}
{\lj {\Gamma, x \!:\! A} {\ul{C}} \quad \cj \Gamma M {\Pi \, x \!:\! A .\, \ul{C}} \quad \vj \Gamma V A}
\\[6mm]
\mkrule
{\hj \Gamma {z \!:\! \ul{C}} {\lambda \, x \!:\! A .\, K} {\Pi \, x \!:\! A .\, \ul{D}}}
{\lj \Gamma {\ul{C}} \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} K \ul{D}}
\qquad
\mkrule
{\hj \Gamma {z \!:\! \ul{C}} {K(V)_{(x : A).\, \ul{D}}} {\ul{D}[V/x]}}
{\lj {\Gamma, x \!:\! A} {\ul{D}} \quad \hj \Gamma {z \!:\! \ul{C}} K {\Pi \, x \!:\! A .\, \ul{D}} \quad \vj \Gamma V A}
\end{array}
\]

\noindent
Congruence rules for the computational $\Pi$-type, lambda abstraction, and function application:
\[
\begin{array}{c}
\mkrule
{\ljeq \Gamma {\Pi \, x \!:\! A_1 .\, \ul{C}_1} {\Pi \, x \!:\! A_2 .\, \ul{C}_2}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{C}_1} {\ul{C}_2}}
\\[6mm]
\mkrule
{\ceq \Gamma {\lambda \, x \!:\! A_1 .\, M_1} {\lambda \, x \!:\! A_2 .\, M_2} {\Pi \, x \!:\! A_1 .\, \ul{C}}}
{\ljeq \Gamma {A_1} {A_2} \quad \ceq {\Gamma, x \!:\! A_1} {M_1} {M_2} {\ul{C}}}
\end{array}
\]

\[
\begin{array}{c}
\mkrule
{\ceq \Gamma {M_1(V_1)_{(x : A_1).\, \ul{C}_1}} {M_2(V_2)_{(x : A_2).\, \ul{C}_2}} {\ul{C}_1[V_1/x]}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{C}_1} {\ul{C}_2} \quad \ceq \Gamma {M_1} {M_2} {\Pi \, x \!:\! A_1 .\, \ul{C}_1} \quad \veq {\Gamma} {V_1} {V_2} {A_1}}
\\[6mm]
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\lambda \, x \!:\! A_1 .\, K_1} {\lambda \, x \!:\! A_2 .\, K_2} {\Pi \, x \!:\! A_1 .\, \ul{D}}}
{\ljeq \Gamma {A_1} {A_2} \quad \lj \Gamma {\ul{C}} \quad \heq {\Gamma, x \!:\! A_1} {z \!:\! \ul{C}} {K_1} {K_2} {\ul{D}}}
\\[6mm]
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {K_1(V_1)_{(x : A_1).\, \ul{D}_1}} {K_2(V_2)_{(x : A_2).\, \ul{D}_2}} {\ul{D}_1[V_1/x]}}
{\ljeq \Gamma {A_1} {A_2} \quad \ljeq {\Gamma, x \!:\! A_1} {\ul{D}_1} {\ul{D}_2} \quad \ceq \Gamma {K_1} {K_2} {\Pi \, x \!:\! A_1 .\, \ul{D}_1} \quad \veq {\Gamma} {V_1} {V_2} {A_1}}
\end{array}
\]

\vspace{0.25cm}

\noindent
$\beta$- and $\eta$-equations for computational lambda abstraction and function application:
\vspace{0.05cm}
\[
\begin{array}{c}
\mkrule
{\ceq \Gamma {(\lambda \, x \!:\! A .\, M)(V)_{(x : A) .\, \ul{C}}} {M[V/x]} {\ul{C}[V/x]}}
{\cj {\Gamma, x \!:\! A} M \ul{C} \quad \vj \Gamma V A}
\\[6mm]
\mkrule
{\ceq \Gamma {M} {\lambda \, x \!:\! A .\, M(x)_{(x : A) .\, \ul{C}}} {\Pi \, x \!:\! A .\, \ul{C}}}
{\lj {\Gamma, x \!:\! A} {\ul{C}} \quad \cj \Gamma M {\Pi \, x \!:\! A .\, \ul{C}}}
\\[6mm]
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {(\lambda \, x \!:\! A .\, K)(V)_{(x : A) .\, \ul{D}}} {K[V/x]} {\ul{D}[V/x]}}
{\lj \Gamma {\ul{C}} \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} K \ul{D} \quad \vj \Gamma V A}
\\[6mm]
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {K} {\lambda \, x \!:\! A .\, K(x)_{(x : A) .\, \ul{D}}} {\Pi \, x \!:\! A .\, \ul{D}}}
{\lj {\Gamma, x \!:\! A} {\ul{D}} \quad \hj \Gamma {z \!:\! \ul{C}} K {\Pi \, x \!:\! A .\, \ul{D}}}
\end{array}
\]

\vspace{0.1cm}

\subsection*{Convention for proving definitional equations}

In this thesis we use the following convention: when we say that we prove a definitional equation $\veq \Gamma {V_1} {V_n} A$, we formally mean constructing a corresponding derivation using the rules given above. In order to improve the readability of these proofs, we omit the full derivations and instead present the proofs as sequences of equations
\[
\Gamma \vdash V_1 = V_2 = \ldots = V_{n-1} = V_n : A
\]
where each individual equation corresponds to a derivation of  $\veq \Gamma {V_i} {V_j} A$, and the sequence as a whole corresponds to the derivation of $\veq \Gamma {V_1} {V_n} A$ by repeated use of the transitivity rule on these individual derivations. These individual derivations often consist of an application of a  $\beta$- or $\eta$-rule under some number of congruence rules.



\section{Meta-theory}
\label{sect:metatheory}

In this section we prove various meta-theoretical properties of the well-formed syntax of eMLTT we introduced in the previous section; these include closure under weakening and substitution, and that well-typed terms are assigned only well-formed types. 

We begin with some properties of well-formed value contexts. First, we show that all value types in a well-formed value context are themselves well-formed.

\begin{proposition}
\label{prop:wellformedtypesinwellformedcontexts}
Given value contexts $\Gamma_1$ and $\Gamma_2$, a value variable $x$, and a value type $A$ such that $\vdash \Gamma_1, x \!:\! A, \Gamma_2$, then we also have $\lj {\Gamma_1} A$.
\end{proposition}

\begin{proof}
By induction on the length of $\Gamma_2$ and by observing that in each of the cases the derivation of $\vdash \Gamma_1, x \!:\! A, \Gamma_2$ has to end with the context extension rule. 
\end{proof}

Next, we observe that our axiomatisation of definitionally equal value contexts in terms of a reflexivity rule for the empty context and a congruence rule for context extension gives rise to an equivalence relation. 

\begin{proposition}
The following rules are admissible for value contexts:
\[
\mkrule
{\ljeq {} \Gamma \Gamma}
{\vdash \Gamma}
\qquad
\mkrule
{\ljeq {} {\Gamma_1} {\Gamma_2}}
{\ljeq {} {\Gamma_2} {\Gamma_1}}
\qquad
\mkrule
{\ljeq {} {\Gamma_1} {\Gamma_3}}
{\ljeq {} {\Gamma_1} {\Gamma_2} \quad \ljeq {} {\Gamma_2} {\Gamma_3}}
\]
\end{proposition}

\begin{proof}
We prove reflexivity by induction on the derivation of $\vdash \Gamma$, symmetry by induction on the derivation of $\ljeq {} {\Gamma_2} {\Gamma_1}$, and transitivity by induction on the sum of the heights of the derivations of $\ljeq {} {\Gamma_1} {\Gamma_2}$ and $\ljeq {} {\Gamma_2} {\Gamma_3}$. We use the reflexivity, 
symmetry, transitivity, and context conversion rules for value types where needed.
\end{proof}



Next, we show that definitionally equal value contexts have the same structure.

\begin{proposition}
\label{prop:setsofvariablesofequalcontexts}
Given $\Gamma_1$ and $\Gamma_2$ such that ${\ljeq {} {\Gamma_1} {\Gamma_2}}$, then $V\!ars(\Gamma_1) = V\!ars(\Gamma_2)$; and moreover, these value variables  
are given in the same exact order in both contexts.
\end{proposition}

\begin{proof}
By induction on the derivation of $\ljeq {} {\Gamma_1} {\Gamma_2}$.
\end{proof}

\begin{proposition}
\label{prop:equalcontextconcatenation1}
Given value contexts $\Gamma_1$ and $\Gamma_2$ and $\Gamma_3$ such that $\ljeq {} {\Gamma_1, \Gamma_2} {\Gamma_3}$, then there exist value contexts $\Gamma_4$ and $\Gamma_5$ such that $\Gamma_3 = \Gamma_4, \Gamma_5$ and $\ljeq {} {\Gamma_1} {\Gamma_4}$.
\end{proposition}

\begin{proof}
By induction on the length of $\Gamma_2$. 
\end{proof}

\begin{corollary}
\label{cor:equalcontextconcatenation2}
Given value contexts $\Gamma_1$ and $\Gamma_2$ and $\Gamma_3$, a value variable $x$, and a value type $A$ such that $\ljeq {} {\Gamma_1, x \!:\! A, \Gamma_2} {\Gamma_3}$, then there exist value contexts $\Gamma_4$ and $\Gamma_5$, and a value type $B$ such that $\Gamma_3 = \Gamma_4, x \!:\! B, \Gamma_5$ and $\ljeq {} {\Gamma_1} {\Gamma_4}$ and $\ljeq {\Gamma_1} {A} {B}$.
\end{corollary}

\begin{proof}
We use Proposition~\ref{prop:equalcontextconcatenation1} with value contexts $\Gamma_1, x \!:\! A$ and $\Gamma_2$ and $\Gamma_3$, and observe that the last rule used in the derivation of $\vdash {\Gamma_1, x \!:\! A} = \Gamma_4$ has to be the congruence rule for definitionally equal value contexts, giving us the required value type $B$.
\end{proof}

\begin{proposition}
\label{prop:contextextensionwithcontext}
Given value contexts $\Gamma_1$ and $\Gamma_2$ and $\Gamma$ such that $\ljeq {} {\Gamma_1} {\Gamma_2}$ and $\lj {} {\Gamma_1,\Gamma}$, then $\ljeq {} {\Gamma_1,\Gamma} {\Gamma_2,\Gamma}$.
\end{proposition}

\begin{proof}
By induction on the length of $\Gamma$. 
\end{proof}

Next, we show that the free value variables of a well-formed expression are contained in the value context in which the given expression is well-formed.


\begin{proposition} \mbox{}
\label{prop:freevariablesofwellformedexpressions}
\begin{enumerate}[(a)]
\item Given $\lj \Gamma A$, then $FVV(A) \subseteq V\!ars(\Gamma)$.
\item Given $\ljeq \Gamma A B$, then $FVV(A) \subseteq V\!ars(\Gamma)$ and $FVV(B) \subseteq V\!ars(\Gamma)$.
\item Given $\lj \Gamma \ul{C}$, then $FVV(\ul{C}) \subseteq V\!ars(\Gamma)$.
\item Given $\ljeq \Gamma {\ul{C}} {\ul{D}}$, then $FVV(\ul{C}) \subseteq V\!ars(\Gamma)$ and $FVV(\ul{D}) \subseteq V\!ars(\Gamma)$.
\item Given $\vj \Gamma V A$, then $FVV(V) \subseteq V\!ars(\Gamma)$ and $FVV(A) \subseteq V\!ars(\Gamma)$.
\item Given $\veq \Gamma V W A$, then $FVV(V) \subseteq V\!ars(\Gamma)$, $FVV(W) \subseteq V\!ars(\Gamma)$, and \\$FVV(A) \subseteq V\!ars(\Gamma)$.
\item Given $\cj \Gamma M \ul{C}$, then $FVV(M) \subseteq V\!ars(\Gamma)$ and $FVV(\ul{C}) \subseteq V\!ars(\Gamma)$.
\item Given $\ceq \Gamma M N \ul{C}$, then $FVV(M) \subseteq V\!ars(\Gamma)$, $FVV(N) \subseteq V\!ars(\Gamma)$, and \\ $FVV(\ul{C}) \subseteq V\!ars(\Gamma)$.
\item Given $\hj \Gamma {z \!:\! \ul{C}} K \ul{D}$, then $FVV(\ul{C}) \subseteq V\!ars(\Gamma)$, $FVV(K) \subseteq V\!ars(\Gamma)$, and \\ $FVV(\ul{D}) \subseteq V\!ars(\Gamma)$.
\item Given $\heq \Gamma {z \!:\! \ul{C}} K L \ul{D}$, then $FVV(\ul{C}) \subseteq V\!ars(\Gamma)$, $FVV(K) \subseteq V\!ars(\Gamma)$, \\ $FVV(L) \subseteq V\!ars(\Gamma)$, and $FVV(\ul{D}) \subseteq V\!ars(\Gamma)$.
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(j)$ simultaneously, by induction on the derivations of the given judgements, using Proposition~\ref{prop:freevariablesofsubsstitution} for rules involving the substitution of value terms for value variables.
\end{proof}

Analogously, we can also show that the free computation variable of a well-typed homomorphism term matches the computation variable mentioned in its typing judgement, and analogously for definitional equations between homomorphism terms:



\pagebreak

\begin{proposition} \mbox{}
\label{prop:freecomputationvariables}
\begin{enumerate}[(a)]
\item Given $\hj \Gamma {z \!:\! \ul{C}} K {\ul{D}}$, then $FCV(K) = z$.
\item Given $\heq \Gamma {z \!:\! \ul{C}} K L {\ul{D}}$, then $FCV(K) = z$ and $FCV(L) = z$.
\end{enumerate}
\end{proposition}

\begin{proof}
We first prove $(a)$ and then $(b)$, by induction on the given derivations of \linebreak $\hj \Gamma {z \!:\! \ul{C}} K {\ul{D}}$ and  $\heq \Gamma {z \!:\! \ul{C}} K L {\ul{D}}$, respectively. In the cases that involve substituting homomorphism terms for computation variables, we use Proposition~\ref{prop:compvariableofhomsubst}.
\end{proof}

We are now ready to prove that the judgements of eMLTT are closed under weakening of value contexts and under substitution of value terms for value variables. 

\begin{theorem}[Weakening] 
\label{thm:weakening}
\index{weakening theorem!syntactic --}
Assuming that $x \not\in V\!ars(\Gamma_1,\Gamma_2)$ and $\lj {\Gamma_1} A$, we have:
\label{thm:weakening}
\begin{enumerate}[(a)]
\item Given $\vdash {\Gamma_1,\Gamma_2}$, then $\vdash {\Gamma_1,x \!:\! A,\Gamma_2}$.
\item Given $\ljeq{} {\Gamma_1,\Gamma_2} {\Gamma_3,\Gamma_4}$, then $\ljeq {} {\Gamma_1,x \!:\! A,\Gamma_2} {\Gamma_3,x \!:\! A,\Gamma_4}$.
\item Given $\lj {\Gamma_1,\Gamma_2} B$, then $\lj {\Gamma_1,x \!:\! A,\Gamma_2} B$.
\item Given $\ljeq {\Gamma_1,\Gamma_2} {B_1} {B_2}$, then $\ljeq {\Gamma_1,x \!:\! A,\Gamma_2} {B_1} {B_2}$.
\item Given $\lj {\Gamma_1,\Gamma_2} \ul{C}$, then $\lj {\Gamma_1,x \!:\! A,\Gamma_2} \ul{C}$.
\item Given $\ljeq {\Gamma_1,\Gamma_2} {\ul{C}} {\ul{D}}$, then $\ljeq {\Gamma_1,x \!:\! A,\Gamma_2} {\ul{C}} {\ul{D}}$.
\item Given $\vj {\Gamma_1,\Gamma_2} V B$, then $\vj {\Gamma_1,x \!:\! A,\Gamma_2} V B$.
\item Given $\veq {\Gamma_1,\Gamma_2} V W B$, then $\veq {\Gamma_1,x \!:\! A,\Gamma_2} V W B$.
\item Given $\cj {\Gamma_1,\Gamma_2} M \ul{C}$, then $\cj {\Gamma_1,x \!:\! A,\Gamma_2} M \ul{C}$.
\item Given $\ceq {\Gamma_1,\Gamma_2} M N \ul{C}$, then $\ceq {\Gamma_1,x \!:\! A,\Gamma_2} M N \ul{C}$.
\item Given $\hj {\Gamma_1,\Gamma_2} {z \!:\! \ul{C}} K \ul{D}$, then $\hj {\Gamma_1,x \!:\! A,\Gamma_2} {z \!:\! \ul{C}} K \ul{D}$.
\item Given $\heq {\Gamma_1,\Gamma_2} {z \!:\! \ul{C}} K L \ul{D}$, then $\heq {\Gamma_1,x \!:\! A,\Gamma_2} {z \!:\! \ul{C}} K L \ul{D}$.
\end{enumerate}
\end{theorem}

\begin{proof}
We prove this theorem simultaneously with Theorem~\ref{thm:substitution}.
We prove all cases simultaneously: $(a)$--$(b)$ by induction on the length of $\Gamma_2$ 
and $(c)$--$(l)$ by induction on the derivations of the given judgements. 
We sketch the proofs of two cases that need extra work, namely, those involving context and type conversions, and substitution. 

\vspace{0.2cm}

\noindent \textbf{Context and type conversion rule for computation terms:}
In this case, the given derivation ends with
\[
\mkrule
{\cj {\Gamma_1,\Gamma_2} M {\ul{D}}}
{\cj {\Gamma_3} M {\ul{C}} \quad \vdash \Gamma_3 = \Gamma_1,\Gamma_2 \quad \ljeq {\Gamma_3} {\ul{C}} {\ul{D}}}
\]
and we are required to construct a derivation of ${\cj {\Gamma_1, x \!:\! A,\Gamma_2} M {\ul{D}}}$.

First, by using Proposition~\ref{prop:equalcontextconcatenation1}, together with the symmetry of definitionally equal value contexts, we get that $\Gamma_3 = \Gamma_4,\Gamma_5$ and $\ljeq {} {\Gamma_1} {\Gamma_4}$, for some $\Gamma_4$ and $\Gamma_5$. 

Next, by combining this definitional equation with the context and type conversion rule for value types, we get a derivation of $\lj {\Gamma_4} A$.

Next, we observe that our assumptions give us that $x \not\in V\!ars(\Gamma_1,\Gamma_2)$, and Proposition~\ref{prop:setsofvariablesofequalcontexts} gives us that $V\!ars(\Gamma_1,\Gamma_2) = V\!ars(\Gamma_3) = V\!ars(\Gamma_4,\Gamma_5)$. 

Therefore, we can use the induction hypothesis on the derivation of $\cj {\Gamma_4,\Gamma_5} M {\ul{C}}$ to get a derivation of $\cj {\Gamma_4,x \!:\! A,\Gamma_5} M {\ul{C}}$. Analogously, we can use $(b)$ on the derivation of $\ljeq {} {\Gamma_4,\Gamma_5} {\Gamma_1,\Gamma_2}$ to get a derivation of $\ljeq {} {\Gamma_4,x \!:\! A,\Gamma_5} {\Gamma_1,x \!:\! A,\Gamma_2}$, and $(f)$ on the derivation of $\ljeq {\Gamma_4,\Gamma_5} {\ul{C}} {\ul{D}}$ to get a derivation of $\ljeq {\Gamma_4,x \!:\! A,\Gamma_5} {\ul{C}} {\ul{D}}$.

As a result, we can now construct the required derivation, as shown below:
\[
\mkrule
{\cj {\Gamma_1, x \!:\! A,\Gamma_2} M {\ul{D}}}
{\cj {\Gamma_4,x \!:\! A,\Gamma_5} M {\ul{C}} \quad \vdash \Gamma_4,x \!:\! A,\Gamma_5 = \Gamma_1, x \!:\! A,\Gamma_2 \quad \ljeq {\Gamma_4,x \!:\! A,\Gamma_5} {\ul{C}} {\ul{D}}}
\]

Other cases involving context and type conversion rules are proved analogously.

\vspace{0.2cm}

\noindent \textbf{Replacement rule for computation terms:}
In this case, the given derivation ends with
\[
\mkrule
{\ceq {\Gamma_3, \Gamma_4[V_1/y]} {M[V_1/y]} {M[V_2/y]} {\ul{C}[V_1/y]}}
{\vj {\Gamma_3, y \!:\! B, \Gamma_4} M {\ul{C}} \quad \veq {\Gamma_3} {V_1} {V_2} {B}}
\]
with $\Gamma_1,\Gamma_2 = \Gamma_3, \Gamma_4[V_1/y]$. 

We now have two possibilities to consider, according to how $\Gamma_1$ and $\Gamma_3$ overlap. 
%
In both cases, we note that our adopted variable convention does not apply because $y$ is not a bound value variable. As a result, it is not guaranteed that $x$ and $y$ are different. To overcome this, we choose a fresh $y'$ satisfying $y' \not\in V\!ars(\Gamma_3, y \!:\! B, \Gamma_4)$ and $y' \neq x$.


\vspace{0.2cm}
\noindent
\emph{Case for $V\!ars(\Gamma_3) \subseteq V\!ars(\Gamma_1)$}: In this case, the value context $\Gamma_4[V_1/y]$ is of the form $\Gamma_{41}[V_1/y], \Gamma_{42}[V_1/y]$, with $\Gamma_1 = \Gamma_3,\Gamma_{41}[V_1/y]$ and $\Gamma_2 = \Gamma_{42}[V_1/y]$, and we are required to construct a derivation of
\[
\ceq {\Gamma_3, \Gamma_{41}[V_1/y], x \!:\! A, \Gamma_{42}[V_1/y]} {M[V_1/y]} {M[V_2/y]} {\ul{C}[V_1/y]}
\]

Based on that ${y' \not\in V\!ars(\Gamma_3, y \!:\! B, \Gamma_4)}$, we can use $(i)$ on the given derivation of \linebreak$\cj {\Gamma_3, y \!:\! B, \Gamma_{41}, \Gamma_{42}} M {\ul{C}}$ to get a derivation of $\cj {\Gamma_3, y' \!:\! B, y \!:\! B, \Gamma_{41}, \Gamma_{42}} M {\ul{C}}$, \linebreak on which we can in turn use $(i)$ of Theorem~\ref{thm:substitution} to get a derivation of \linebreak $\cj {\Gamma_{3}, y' \!:\! B, \Gamma_{41}[y'/y], \Gamma_{42}[y'/y]} {M[y'/y]} {\ul{C}[y'/y]}$.

Next, we observe that $x \not\in V\!ars(\Gamma_3, y' \!:\! B, \Gamma_{41}[y'/y], \Gamma_{42}[y'/y])$.
Therefore, we can use $(i)$ on the derivation of $\cj {\Gamma_3, y' \!:\! B, \Gamma_{41}[y'/y], \Gamma_{42}[y'/y]} {M[y'/y]} {\ul{C}[y'/y]}$ to get a derivation of $\cj {\Gamma_3, y' \!:\! B, \Gamma_{41}[y'/y], x \!:\! A, \Gamma_{42}[y'/y]} {M[y'/y]} {\ul{C}[y'/y]}$. 

Now, by applying the replacement rule for computation terms on this derivation, we get a derivation ending with
\[
\mkrulelabel
{
\begin{array}{c@{~} c@{~} l}
{\Gamma_3, \Gamma_{41}[y'/y][V_1/y'], x \!:\! A[V_1/y'], \Gamma_{42}[y'/y][V_1/y']} & \vdash & {M[y'/y][V_1/y']}
\\
& = & {M[y'/y][V_2/y']} : {\ul{C}[y'/y][V_1/y']}
\end{array}
}
{\cj {\Gamma_3, y' \!:\! B, \Gamma_{41}[y'/y],x \!:\! A,\Gamma_{42}[y'/y]} {M[y'/y]} {\ul{C}[y'/y]} \quad \veq {\Gamma_3} {V_1} {V_2} {B}}
{(*)}
\]

Next, according to Proposition~\ref{prop:freevariablesofwellformedexpressions}, we know that $FVV(V_1) \subseteq V\!ars(\Gamma_3)$ and $FVV(V_2) \subseteq V\!ars(\Gamma_3)$. Therefore, we have that $y \not\in FVV(V_1)$ and $y \not\in FVV(V_2)$. 
% 
\linebreak
Furthermore, as a consequence of the way we have chosen $y'$, we also know that $y' \not\in FVV(\Gamma_{41})$, $y' \not\in FVV(\Gamma_{42})$, $y' \not\in FVV(M)$, $y' \not\in FVV(A)$, and $y' \not\in FVV(\ul{C})$. 

By combining these observations with Definition~\ref{def:substvaluevariables} and Propositions~\ref{prop:valuesubstlemma1},~\ref{prop:valuesubstlemma3}, and~\ref{prop:contextsubstlemma}, we can  show that the following equations hold:
\[
\begin{array}{c}
\Gamma_{41}[y'/y][V_1/y'] = \Gamma_{41}[V_1/y'][y'[V_1/y']/y] = \Gamma_{41}[y'[V_1/y']/y] = \Gamma_{41}[V_1/y]
\\[1mm]
A[V_1/y'] = A
\\[1mm]
\Gamma_{42}[y'/y][V_1/y'] = \Gamma_{42}[V_1/y'][y'[V_1/y']/y] = \Gamma_{42}[y'[V_1/y']/y] = \Gamma_{42}[V_1/y]
\\[1mm]
M[y'/y][V_1/y'] = M[V_1/y'][y'[V_1/y']/y] = M[y'[V_1/y']/y] = M[V_1/y]
\\[1mm]
M[y'/y][V_2/y'] = M[V_2/y'][y'[V_2/y']/y] = M[y'[V_2/y']/y] = M[V_2/y]
\\[1mm]
\ul{C}[y'/y][V_1/y'] = \ul{C}[V_1/y'][y'[V_1/y']/y] = \ul{C}[y'[V_1/y']/y] = \ul{C}[V_1/y]
\end{array}
\]

As a result, the derivation we constructed above that ends with $(*)$ gives us the required derivation of
$
\ceq {\Gamma_3, \Gamma_{41}[V_1/y], x \!:\! A, \Gamma_{42}[V_1/y]} {M[V_1/y]} {M[V_2/y]} {\ul{C}[V_1/y]}
$.

\vspace{0.2cm}
\noindent
\emph{Case for $V\!ars(\Gamma_3) \not\subseteq V\!ars(\Gamma_1)$}: In this case, the value context $\Gamma_3$ is of the form $\Gamma_{31}, \Gamma_{32}$, with $\Gamma_1 = \Gamma_{31}$ and $\Gamma_2 = \Gamma_{32},\Gamma_4[V_1/y]$, and we are required to construct a derivation of 
\[
\ceq {\Gamma_{31}, x \!:\! A,\Gamma_{32}, \Gamma_4[V_1/y]} {M[V_1/y]} {M[V_2/y]} {\ul{C}[V_1/y]}
\]

Based on that $y' \not\in V\!ars(\Gamma_3, y \!:\! B, \Gamma_4)$, we can use $(i)$ on the derivation of \linebreak$\cj {\Gamma_{31},\Gamma_{32}, y \!:\! B, \Gamma_4} M {\ul{C}}$ to get a derivation of $\cj {\Gamma_{31},\Gamma_{32}, y' \!:\! B, y \!:\! B, \Gamma_4} M {\ul{C}}$, \linebreak on which we can in turn use $(i)$ of Theorem~\ref{thm:substitution} to get a derivation of \linebreak $\cj {\Gamma_{31},\Gamma_{32}, y' \!:\! B, \Gamma_4[y'/y]} {M[y'/y]} {\ul{C}[y'/y]}$.

Next, we observe that $x \not\in V\!ars(\Gamma_{31},\Gamma_{32}, y' \!:\! B, \Gamma_4[y'/y])$.
%
Therefore, we can use $(i)$ on the derivation of $\cj {\Gamma_{31},\Gamma_{32}, y' \!:\! B, \Gamma_4[y'/y]} {M[y'/y]} {\ul{C}[y'/y]}$ to get a derivation of $\cj {\Gamma_{31}, x \!:\! A,\Gamma_{32}, y' \!:\! B, \Gamma_4[y'/y]} {M[y'/y]} {\ul{C}[y'/y]}$. 
Furthermore, as we also know that $x \not\in V\!ars(\Gamma_{31},\Gamma_{32})$, we can use $(h)$ on the derivation of $\veq {\Gamma_{31},\Gamma_{32}} {V_1} {V_2} {B}$ to get a derivation of $\veq {\Gamma_{31},x \!:\! A,\Gamma_{32}} {V_1} {V_2} {B}$. 

Now, by applying the replacement rule for computation terms on these derivations we get a derivation ending with 
\[
\mkrulelabel
{\ceq {\Gamma_{31}, x \!:\! A,\Gamma_{32}, \Gamma_4[y'/y][V_1/y']} {M[y'/y][V_1/y']} {M[y'/y][V_2/y']} {\ul{C}[y'/y][V_1/y']}}
{\cj {\Gamma_{31}, x \!:\! A,\Gamma_{32}, y' \!:\! B, \Gamma_4[y'/y]} {M[y'/y]} {\ul{C}[y'/y]} \quad \veq {\Gamma_{31}, x \!:\! A,\Gamma_{32}} {V_1} {V_2} {B}}
{(**)}
\]

Next, according to Proposition~\ref{prop:freevariablesofwellformedexpressions}, we know that $FVV(V_1) \subseteq V\!ars(\Gamma_{31},\Gamma_{32})$ and $FVV(V_2) \subseteq V\!ars(\Gamma_{31},\Gamma_{32})$. Therefore, we have that $y \not\in FVV(V_1)$ and $y \not\in FVV(V_2)$. Furthermore, as a consequence of the way we have picked $y'$, we also know that  \linebreak $y' \not\in FVV(\Gamma_4)$, $y' \not\in FVV(M)$, and $y' \not\in FVV(\ul{C})$. 

By combining these observations with Definition~\ref{def:substvaluevariables} and Propositions~\ref{prop:valuesubstlemma1},~\ref{prop:valuesubstlemma3}, and~\ref{prop:contextsubstlemma},  we can  show that the following equations hold: 
\[
\begin{array}{c}
\Gamma_4[y'/y][V_1/y'] = \Gamma_4[V_1/y'][y'[V_1/y']/y] = \Gamma_4[y'[V_1/y']/y] = \Gamma_4[V_1/y]
\\[1mm]
M[y'/y][V_1/y'] = M[V_1/y'][y'[V_1/y']/y] = M[y'[V_1/y']/y] = M[V_1/y]
\\[1mm]
M[y'/y][V_2/y'] = M[V_2/y'][y'[V_2/y']/y] = M[y'[V_2/y']/y] = M[V_2/y]
\\[1mm]
\ul{C}[y'/y][V_1/y'] = \ul{C}[V_1/y'][y'[V_1/y']/y] = \ul{C}[y'[V_1/y']/y] = \ul{C}[V_1/y]
\end{array}
\]

As a result, the derivation we constructed above that ends with $(**)$ gives us the required derivation for
$
\ceq {\Gamma_{31}, x \!:\! A,\Gamma_{32}, \Gamma_4[V_1/y]} {M[V_1/y]} {M[V_2/y]} {\ul{C}[V_1/y]}
$.

Other cases that involve substitution in rule conclusions are proved analogously.
\end{proof}

\begin{theorem}[Value term substitution] 
\label{thm:substitution}
\index{substitution theorem!syntactic --!-- for value terms}
Assuming $\vj {\Gamma_1} V A$, we have:
\begin{enumerate}[(a)]
\item Given $\vdash {\Gamma_1, x \!:\! A,\Gamma_2}$, then $\vdash {\Gamma_1,\Gamma_2[V/x]}$.
\item Given $\ljeq{} {\Gamma_1, x \!:\! A,\Gamma_2} {\Gamma_3, x \!:\! A',\Gamma_4}$, then $\ljeq {} {\Gamma_1,\Gamma_2[V/x]} {\Gamma_3,\Gamma_4[V/x]}$.
\item Given $\lj {\Gamma_1, x \!:\! A,\Gamma_2} B$, then $\lj {\Gamma_1,\Gamma_2[V/x]} B[V/x]$.
\item Given $\ljeq {\Gamma_1,x \!:\! A,\Gamma_2} {B_1} {B_2}$, then $\ljeq {\Gamma_1,\Gamma_2[V/x]} {B_1[V/x]} {B_2[V/x]}$.
\item Given $\lj {\Gamma_1,x \!:\! A,\Gamma_2} \ul{C}$, then $\lj {\Gamma_1,\Gamma_2[V/x]} \ul{C}[V/x]$.
\item Given $\ljeq {\Gamma_1,x \!:\! A,\Gamma_2} {\ul{C}} {\ul{D}}$, then $\ljeq {\Gamma_1,\Gamma_2[V/x]} {\ul{C}[V/x]} {\ul{D}[V/x]}$.
\item Given $\vj {\Gamma_1,x \!:\! A,\Gamma_2} W B$, then $\vj {\Gamma_1,\Gamma_2[V/x]} {W[V/x]} {B[V/x]}$.
\item Given $\veq {\Gamma_1,x \!:\! A,\Gamma_2} {W_1} {W_2} B$, then $\veq {\Gamma_1,\Gamma_2[V/x]} {W_1[V/x]} {W_2[V/x]} {B[V/x]}$.
\item Given $\cj {\Gamma_1,x \!:\! A,\Gamma_2} M \ul{C}$, then $\cj {\Gamma_1,\Gamma_2[V/x]} {M[V/x]} {\ul{C}[V/x]}$.
\item Given $\ceq {\Gamma_1,x \!:\! A,\Gamma_2} M N \ul{C}$, then $\ceq {\Gamma_1,\Gamma_2[V/x]} {M[V/x]} {N[V/x]} {\ul{C}[V/x]}$.
\item Given $\hj {\Gamma_1,x \!:\! A,\Gamma_2} {z \!:\! \ul{C}} K \ul{D}$, then $\hj {\Gamma_1,\Gamma_2[V/x]} {z \!:\! \ul{C}[V/x]} {K[V/x]} {\ul{D}[V/x]}$.
\item Given $\heq {\Gamma_1,x \!:\! A,\Gamma_2} {z \!:\! \ul{C}} K L \ul{D}$, then 

\hfill$\heq {\Gamma_1,\Gamma_2[V/x]} {z \!:\! \ul{C}[V/x]} {K[V/x]} {L[V/x]} {\ul{D}[V/x]}$.
\end{enumerate}
\end{theorem}

\begin{proof}
We prove this theorem simultaneously with Theorem~\ref{thm:weakening}.
We prove all cases simultaneously: $(a)$--$(b)$ by induction on the length of $\Gamma_2$ and $(c)$--$(l)$ by induction on the derivations of the given judgements. We sketch the proofs of three cases that need extra work, namely, those involving context and type conversions, and substitution.

\vspace{0.2cm}

\noindent \textbf{Context and type conversion rule for computation terms:}
In this case, the given derivation ends with
\[
\mkrule
{\cj {\Gamma_1, x \!:\! A,\Gamma_2} M {\ul{D}}}
{\cj {\Gamma_3} M {\ul{C}} \quad \vdash \Gamma_3 = \Gamma_1, x \!:\! A,\Gamma_2 \quad \ljeq {\Gamma_3} {\ul{C}} {\ul{D}}}
\]
and we are required to construct a derivation of ${\cj {\Gamma_1, \Gamma_2[V/x]} {M[V/x]} {\ul{D}[V/x]}}$.

First, using Corollary~\ref{cor:equalcontextconcatenation2}, together with the symmetry of definitionally equal value contexts, we get that $\Gamma_3 = \Gamma_4, x \!:\! B,\Gamma_5$ and $\ljeq{} {\Gamma_1} {\Gamma_4}$ and $\ljeq {\Gamma_1} {A} {B}$, for some value contexts $\Gamma_4$ and $\Gamma_5$, and a value type $B$. 

Next, by combining these definitional equations with the context and type conversion rule for value terms, we get a derivation of $\vj {\Gamma_4} V {B}$.  

As a result, we can use the induction hypothesis on the given derivation of \linebreak $\cj {\Gamma_4, x \!:\! B,\Gamma_5} M {\ul{C}}$ to get a derivation of $\cj {\Gamma_4,\Gamma_5[V/x]} {M[V/x]} {\ul{C}[V/x]}$. Analogously, we can use $(b)$ on the derivation of $\ljeq {} {\Gamma_4, x \!:\! B,\Gamma_5} {\Gamma_1, x \!:\! A,\Gamma_2}$ to get a derivation of  $\ljeq {} {\Gamma_4,\Gamma_5[V/x]} {\Gamma_1,\Gamma_2[V/x]}$, and $(d)$ on the derivation of $\ljeq {\Gamma_4, x \!:\! B,\Gamma_5} {\ul{C}} {\ul{D}}$ to get a derivation of $\ljeq {\Gamma_4,\Gamma_5[V/x]} {\ul{C}[V/x]} {\ul{D}[V/x]}$.

As a result, we can now construct the required derivation, as shown below:
\[
\mkrule
{\cj {\Gamma_1, \Gamma_2[V/x]} {M[V/x]} {\ul{D}[V/x]}}
{
\begin{array}{c}
(1)
\quad
\vdash \Gamma_4,\Gamma_5[V/x] = \Gamma_1,\Gamma_2[V/x] \quad \ljeq {\Gamma_4,\Gamma_5[V/x]} {\ul{C}[V/x]} {\ul{D}[V/x]}
\end{array}
}
\]
where $(1)$ denotes a derivation of
\[
\cj {\Gamma_4,\Gamma_5[V/x]} {M[V/x]} {\ul{C}[V/x]} 
\]

Other cases involving context and type conversion rules are proved analogously.

\vspace{0.2cm}

\noindent \textbf{Typing rule for computational pairing:}
In this case, the given derivation ends with
\[
\mkrule
{\cj {\Gamma_1, x \!:\! A,\Gamma_2} {\langle W , M \rangle_{(y : B).\, \ul{C}}} {\Sigma \, y \!:\! B .\, \ul{C}}}
{\vj {\Gamma_1, x \!:\! A,\Gamma_2} W B \quad \lj {\Gamma_1, x \!:\! A,\Gamma_2, y \!:\! B} {\ul{C}} \quad \cj {\Gamma_1, x \!:\! A,\Gamma_2} M {\ul{C}[W/y]}}
\]
and we are required to construct a derivation of 
\[
\cj {\Gamma_1, \Gamma_2[V/x]} {\langle W[V/x] , M[V/x] \rangle_{(y : B[V/x]).\, \ul{C}[V/x]}} {\Sigma \, y \!:\! B[V/x] .\, \ul{C}[V/x]}
\]

First, we use $(g)$ on the derivation of $\vj {\Gamma_1, x \!:\! A,\Gamma_2} W A$ to get a derivation \linebreak of $\vj {\Gamma_1,\Gamma_2[V/x]} {W[V/x]} {A[V/x]}$. 
Analogously, we use $(e)$ on the given derivation of $\lj {\Gamma_1, x \!:\! A,\Gamma_2, y \!:\! B} {\ul{C}}$ to get a derivation of $\lj {\Gamma_1,\Gamma_2[V/x], y \!:\! B[V/x]} {\ul{C}[V/x]}$. 

Next, we use the induction hypothesis on the derivation of $\cj {\Gamma_1, x \!:\! A,\Gamma_2} M {\ul{C}[W/x]}$ to get a derivation of $\cj {\Gamma_1, \Gamma_2[V/x]} {M[V/x]} {\ul{C}[W/y][V/x]}$, which is the same as a derivation of $\cj {\Gamma_1, \Gamma_2[V/x]} {M[V/x]} {\ul{C}[V/x][W[V/x]/y]}$ due to Proposition~\ref{prop:valuesubstlemma3}. 
In particular, based on our adopted variable convention, we have $y \not\in V\!ars(\Gamma_1, x \!:\! A, \Gamma_2)$, from which it follows that $y \not\in V\!ars(\Gamma_1)$.
Further, according to Proposition~\ref{prop:freevariablesofwellformedexpressions}, we also know that $FVV(V) \subseteq V\!ars(\Gamma_1)$. Therefore, $y \not\in FVV(V)$.
Combining these observations with Proposition~\ref{prop:valuesubstlemma3}, we get that $\ul{C}[W/y][V/x] = \ul{C}[V/x][W[V/x]/y]$.

Finally, we can construct the required derivation by using the typing rule for computational pairing with the derivations we have constructed above, as shown below:
\[
\mkrule
{\cj {\Gamma_1, \Gamma_2[V/x]} {\langle W[V/x] , M[V/x] \rangle_{(y : B[V/x]).\, \ul{C}[V/x]}} {\Sigma \, y \!:\! B[V/x] .\, \ul{C}[V/x]}}
{
\vj {\Gamma_1,\Gamma_2[V/x]} {W[V/x]} {B[V/x]} \quad (1) \quad \cj {\Gamma_1,\Gamma_2[V/x]} {M[V/x]} {\ul{C}[V/x][W[V/x]/y]}
}
\]
where $(1)$ denotes a derivation of 
\[
\lj {\Gamma_1,\Gamma_2[V/x], y \!:\! B[V/x]} {\ul{C}[V/x]} 
\]

Other cases that involve substitution in rule premises are proved analogously.

\vspace{0.2cm}

\noindent \textbf{Replacement rule for computation terms:}
In this case, the given derivation ends with
\[
\mkrule
{\ceq {\Gamma_3, \Gamma_4[V_1/y]} {M[V_1/y]} {M[V_2/y]} {\ul{C}[V_1/y]}}
{\cj {\Gamma_3, y \!:\! B, \Gamma_4} M {\ul{C}} \quad \veq {\Gamma_3} {V_1} {V_2} {B}}
\]
where $\Gamma_1, x \!:\! A,\Gamma_2 = \Gamma_3, \Gamma_4[V_1/y]$. 

Similarly to the analogous case in the proof of Theorem~\ref{thm:weakening}, we now have two possibilities to consider, depending on whether $x \in V\!ars(\Gamma_3)$ or $x \in V\!ars(\Gamma_4[V_1/y])$. 

\vspace{0.2cm}
\noindent
\emph{Case for $x \in V\!ars(\Gamma_3)$}: In this case, the value context $\Gamma_3$ is of the form $\Gamma_{31}, x \!:\! A, \Gamma_{32}$, with $\Gamma_1 = \Gamma_{31}$ and $\Gamma_2 = \Gamma_{31}, \Gamma_4[V_1/y]$, and we are required to construct a derivation of 
\[
\ceq {\Gamma_3, \Gamma_4[V_1/y][V/x]} {M[V_1/y][V/x]} {M[V_2/y][V/x]} {\ul{C}[V_1/y][V/x]}
\]

First, we use $(i)$ on the derivation of $\cj {\Gamma_{31}, x \!:\! A, \Gamma_{32}, y \!:\! B, \Gamma_4} M {\ul{C}}$ to get a \linebreak derivation of $\cj {\Gamma_{31}, \Gamma_{32}[V/x], y \!:\! B[V/x], \Gamma_4[V/x]} {M[V/x]} {\ul{C}[V/x]}$. 

Next, we use $(h)$ on the derivation of $\veq {\Gamma_{31}, x \!:\! A, \Gamma_{32}} {V_1} {V_2} {B}$ to get a derivation of $\veq {\Gamma_{31}, \Gamma_{32}[V/x]} {V_1[V/x]} {V_2[V/x]} {B[V/x]}$. 

Using these derivations, we can use the replacement rule for computation terms to get a derivation ending with
\[
\mkrulelabel
{
\begin{array}{c@{~} c@{~} l}
{\Gamma_3, \Gamma_4[V/x][V_1[V/x]/y]} & \vdash & {M[V/x][V_1[V/x]/y]} 
\\[-1mm]
& = & {M[V/x][V_2[V/x]/y]} : {\ul{C}[V/x][V_1[V/x]/y]}
\end{array}
}
{\cj {\Gamma_3, y \!:\! B[V/x], \Gamma_4[V/x]} {M[V/x]} {\ul{C}} \quad \veq {\Gamma_3[V/x]} {V_1[V/x]} {V_2[V/x]} {B[V/x]}}
{(*)}
\]

Next, according to Proposition~\ref{prop:freevariablesofwellformedexpressions}, we know that $FVV(V) \subseteq V\!ars(\Gamma_{31})$. Therefore, as $y \not\in V\!ars(\Gamma_{31})$, we also know that $y \not\in FVV(V)$. 

By combining these observations with Propositions~\ref{prop:valuesubstlemma3} and~\ref{prop:contextsubstlemma}, we can show that the following equations hold: 
\[
\begin{array}{c}
\Gamma_4[V/x][V_1[V/x]/y] = \Gamma_4[V_1/y][V/x]
\\[1mm]
M[V/x][V_1[V/x]/y] = M[V_1/y][V/x]
\\[1mm]
M[V/x][V_2[V/x]/y] = M[V_2/y][V/x]
\\[1mm]
\ul{C}[V/x][V_1[V/x]/y] = \ul{C}[V_1/y][V/x]
\end{array}
\]

As a result, the derivation we constructed above that ends with $(*)$ gives us the required derivation of 
$
\ceq {\Gamma_3, \Gamma_4[V_1/y][V/x]} {M[V_1/y][V/x]} {M[V_2/y][V/x]} {\ul{C}[V_1/y][V/x]}
$.

\vspace{0.2cm}
\noindent
\emph{Case for $x \in V\!ars(\Gamma_4[V_1/y])$}: In this case, the value context $\Gamma_4[V_1/y]$ is of the form $\Gamma_{41}[V_1/y], x \!:\! A[V_1/y], \Gamma_{42}[V_1/y]$, with $\Gamma_1 = \Gamma_3, \Gamma_{41}[V_1/y]$ and $\Gamma_2 = \Gamma_{42}[V_1/y]$, and we are required to construct a derivation of 
\[
\ceq {\Gamma_3, \Gamma_{41}[V_1/y],\Gamma_{42}[V_1/y][V/x]} {M[V_1/y][V/x]} {M[V_2/y][V/x]} {\ul{C}[V_1/y][V/x]}
\]

First, we use $(i)$ on the derivation of $\cj {\Gamma_3, y \!:\! B, \Gamma_{41}, x \!:\! A, \Gamma_{42}} M {\ul{C}}$ to get a derivation of $\cj {\Gamma_3, y \!:\! B, \Gamma_{41}, \Gamma_{42}[V/x]} {M[V/x]} {\ul{C}[V/x]}$. 

Using this derivation, together with the given derivation of $\veq {\Gamma_3} {V_1} {V_2} {B}$, we can  use the replacement rule for computation terms to get a derivation ending with
\[
\mkrulelabel
{\ceq {\Gamma_3, \Gamma_{41}[V_1/y],\Gamma_{42}[V/x][V_1/y]} {M[V/x][V_1/y]} {M[V/x][V_2/y]} {\ul{C}[V/x][V_1/y]}}
{\cj {\Gamma_3, y \!:\! B, \Gamma_{41},\Gamma_{42}[V/x]} {M[V/x]} {\ul{C}[V/x]} \quad \veq {\Gamma_3} {V_1} {V_2} {B}}
{(**)}
\]

Next, according to Proposition~\ref{prop:freevariablesofwellformedexpressions}, we know that $FVV(V) \subseteq V\!ars(\Gamma_3, \Gamma_{41}[V_1/y])$. Therefore, as $y \not\in V\!ars(\Gamma_3, \Gamma_{41}[V_1/y])$, we also know that $y \not\in FVV(V)$. 

In addition, according to Proposition~\ref{prop:freevariablesofwellformedexpressions}, we know that $FVV(V_1) \subseteq V\!ars(\Gamma_3)$ and $FVV(V_2) \subseteq V\!ars(\Gamma_3)$. Therefore, as $x \not\in V\!ars(\Gamma_3)$, we also have that $x \not\in FVV(V_1)$ and $x \not\in FVV(V_2)$. 

By combining these observations with Propositions~\ref{prop:valuesubstlemma1},~\ref{prop:valuesubstlemma3}, and~\ref{prop:contextsubstlemma}, we can show that the following equations hold:
\[
\begin{array}{c}
\Gamma_{42}[V/x][V_1/y] = \Gamma_{42}[V/x][V_1[V/x]/y] = \Gamma_{42}[V_1/y][V/x]
\\[1mm]
M[V/x][V_1/y] = M[V/x][V_1[V/x]/y] = M[V_1/y][V/x]
\\[1mm]
M[V/x][V_2/y] = M[V/x][V_2[V/x]/y] = M[V_2/y][V/x]
\\[1mm]
\ul{C}[V/x][V_1/y] = \ul{C}[V/x][V_1[V/x]/y] = \ul{C}[V_1/y][V/x]
\end{array}
\]

As a result, the above derivation ending with $(**)$ gives us the required derivation of 
$
\ceq {\Gamma_3, \Gamma_{41}[V_1/y],\Gamma_{42}[V_1/y][V/x]} {M[V_1/y][V/x]} {M[V_2/y][V/x]} {\ul{C}[V_1/y][V/x]}
$.

Other cases involving substitution in rule conclusions are proved similarly. In the cases that involve substituting computation terms and homomorphism terms for computation variables, the proofs use Propositions~\ref{prop:compsubstvaluesubst} and~\ref{prop:hompsubstvaluesubst}, respectively.
\end{proof}

In addition to the substitution theorem for value variables, we also prove two substitution theorems for computation variables, one for substituting computation terms and one for substituting homomorphism terms.


\begin{theorem}[Computation term substitution] 
\label{thm:compsubstitution}
\index{substitution theorem!syntactic --!-- for computation terms}
Assuming $\cj {\Gamma} M {\ul{C}}$, we have:
\begin{enumerate}[(a)]
\item Given $\hj {\Gamma} {z \!:\! \ul{C}} K \ul{D}$, then $\cj {\Gamma} {K[M/z]} {\ul{D}}$.
\item Given $\heq {\Gamma} {z \!:\! \ul{C}} K L \ul{D}$, then $\ceq {\Gamma} {K[M/z]} {L[M/z]} {\ul{D}}$.
\end{enumerate}
\end{theorem}

\begin{proof}
We first prove $(a)$ and then $(b)$, by induction on the given derivations of \linebreak $\hj {\Gamma} {z \!:\! \ul{C}} K \ul{D}$ and $\heq {\Gamma} {z \!:\! \ul{C}} K L \ul{D}$, respectively. 
We sketch the proof of a case that needs extra work compared to other cases, namely, the case that involves substitution.

\vspace{0.2cm}

\noindent \textbf{Replacement rule for homomorphism terms:}
In this case, the given derivation ends with
\[
\mkrule
{\heq {\Gamma} {z_2 \!:\! \ul{C}} {K[L_1/z_1]} {K[L_2/z_1]} {\ul{D}_2}}
{\hj {\Gamma} {z_1 \!:\! \ul{D}_1} K {\ul{D}_2} \quad \heq {\Gamma} {z_2 \!:\! \ul{C}} {L_1} {L_2} {\ul{D}_1}}
\]
and we are required to build a derivation of $\ceq {\Gamma} {K[L_1/z_1][M/z_2]} {K[L_2/z_1][M/z_2]} {\ul{D}_2}$.

First, we use the induction hypothesis on the derivation of  $\heq {\Gamma} {z_2 \!:\! \ul{C}} {L_1} {L_2} {\ul{D}_1}$ to get a derivation of $\ceq {\Gamma} {L_1[M/z_2]} {L_2[M/z_2]} {\ul{D}_1}$. 

Next, using this derivation, together with the derivation of $\hj {\Gamma} {z_1 \!:\! \ul{D}_1} K {\ul{D}_2}$, we can use the replacement rule for homomorphism terms to get a derivation ending with
\[
\mkrulelabel
{\ceq {\Gamma} {K[L_1[M/z_2]/z_1]} {K[L_2[M/z_2]/z_1]} {\ul{D}_2}}
{\hj {\Gamma} {z_1 \!:\! \ul{D}_1} K {\ul{D}_2} \quad \ceq {\Gamma} {L_1[M/z_2]} {L_2[M/z_2]} {\ul{D}_1}}
{(*)}
\]

Next, we can use Proposition~\ref{prop:hompsubstcompsubst} to show that the following equations hold: 
\[
\begin{array}{c}
K[L_1[M/z_2]/z_1] = K[L_1/z_1][M/z_2]
\qquad
K[L_2[M/z_2]/z_1] = K[L_2/z_1][M/z_2]
\end{array}
\]

As a result,  the derivation we constructed above that ends with $(*)$ gives us the required derivation of 
$\ceq {\Gamma} {K[L_1/z_1][M/z_2]} {K[L_2/z_1][M/z_2]} {\ul{D}_2}$.

Other cases involving substitution are proved similarly. In the cases that involve substituting value terms for value variables, the proofs use Propositions~\ref{prop:valuesubstlemma1} and~\ref{prop:compsubstvaluesubst}.
\end{proof}



\begin{theorem}[Homomorphism term substitution] 
\label{thm:homsubstitution}
\index{substitution theorem!syntactic --!-- for homomorphism terms}
Assuming $\hj {\Gamma} {z_1 \!:\! \ul{C}} K {\ul{D}_1}$, we have:
\begin{enumerate}[(a)]
\item Given $\hj {\Gamma} {z_2 \!:\! \ul{D}_1} L {\ul{D}_2}$, then $\hj {\Gamma} {z_1 \!:\! \ul{C}} {L[K/z]} {\ul{D}_2}$.
\item Given $\heq {\Gamma} {z_2 \!:\! \ul{D}_1} {L_1} {L_2} {\ul{D}_2}$, then $\heq {\Gamma} {z_1 \!:\! \ul{C}} {L_1[K/z]} {L_2[K/z]} {\ul{D}_2}$.
\end{enumerate}
\end{theorem}

\begin{proof}
We first prove $(a)$ and then $(b)$, by induction on the derivations of \linebreak $\hj {\Gamma} {z_2 \!:\! \ul{D}_1} L {\ul{D}_2}$ and $\heq {\Gamma} {z_2 \!:\! \ul{D}_1} {L_1} {L_2} {\ul{D}_2}$, respectively. 
We sketch the proof of a case that needs extra work compared to other cases, namely, the case that involves substitution.


\vspace{0.2cm}

\noindent \textbf{Replacement rule for homomorphism terms:}
In this case, the given derivation ends with
\[
\mkrule
{\heq {\Gamma} {z_2 \!:\! \ul{D}_1} {L[L_1/z_1]} {L[L_2/z_1]} {\ul{D}_2}}
{\hj {\Gamma} {z_3 \!:\! \ul{D}_3} L {\ul{D}_2} \quad \heq {\Gamma} {z_2 \!:\! \ul{D}_1} {L_1} {L_2} {\ul{D}_3}}
\]
and we are required to construct a derivation of 
\[
{\heq {\Gamma} {z_1 \!:\! \ul{C}} {L[L_1/z_1][K/z_2]} {L[L_2/z_1][K/z_2]} {\ul{D}_2}}
\]

First, we use the induction hypothesis on the derivation of  ${\heq {\Gamma} {z_2 \!:\! \ul{D}_1} {L_1} {L_2} {\ul{D}_3}}$ to get a derivation of $\heq {\Gamma} {z_1 \!:\! \ul{C}} {L_1[K/z_2]} {L_2[K/z_2]} {\ul{D}_1}$. 

Next, using this derivation, together with the derivation of $\hj {\Gamma} {z_3 \!:\! \ul{D}_3} L {\ul{D}_2}$, we can use the replacement rule for homomorphism terms to get a derivation ending with
\[
\mkrulelabel
{\heq {\Gamma} {z_1 \!:\! \ul{C}} {L[L_1[K/z_2]/z_1]} {L[L_2[K/z_2]/z_1]} {\ul{D}_2}}
{\hj {\Gamma} {z_3 \!:\! \ul{D}_3} L {\ul{D}_2} \quad \heq {\Gamma} {z_1 \!:\! \ul{C}} {L_1[K/z_2]} {L_2[K/z_2]} {\ul{D}_3}}
{(*)}
\]

Next, we can use Proposition~\ref{prop:hompsubsthomsubst} to show that the following equations hold: 
\[
\begin{array}{c}
L[L_1[K/z_2]/z_1] = L[L_1/z_1][K/z_2]
\qquad
L[L_2[K/z_2]/z_1] = L[L_2/z_1][K/z_2]
\end{array}
\]

As a result, the derivation we constructed above that ends with $(*)$ gives us the required derivation of 
$\heq {\Gamma} {z_1 \!:\! \ul{C}} {L[L_1/z_1][K/z_2]} {L[L_2/z_1][K/z_2]} {\ul{D}_2}$.

Other cases involving substitution are proved similarly. In the cases that involve substituting value terms for value variables, the proofs use Propositions~\ref{prop:valuesubstlemma1} and~\ref{prop:hompsubstvaluesubst}.
\end{proof}

In the next proposition we show that the value types that are assigned to the same variable in definitionally equal contexts are themselves definitionally equal.

\begin{proposition}
\label{prop:findingvariableinequalcontexts}
Given value contexts $\Gamma_1$ and $\Gamma_2$, a value variable $x$, and a value type $A$ such that $\vdash \Gamma_1 = \Gamma_2$ and $x \!:\! A \in \Gamma_1$, then there exists a value type $B$ such that $x \!:\! B \in \Gamma_2$ and $\ljeq {\Gamma_1} A B$.
\end{proposition}

\begin{proof}
We prove this proposition by induction on the derivation of $\vdash \Gamma_1 = \Gamma_2$, using Theorem~\ref{thm:weakening} when the last variable of $\Gamma_1$ and $\Gamma_2$ is different from $x$ in order to weaken the definitional equation given by the induction hypothesis.
\end{proof}

Next, we prove inversion lemmas for well-formed expressions, showing that the corresponding formation and typing rules can be inverted.


\begin{proposition} 
\label{prop:valuetypeinversion}
The following inversion principles are valid for value types:
\begin{enumerate}[(a)]
\item Given $\lj \Gamma {\Sigma\, x \!:\! A .\, B}$, then $\lj \Gamma A$ and $\lj {\Gamma, x \!:\! A} B$.
\item Given $\lj \Gamma {\Pi\, x \!:\! A .\, B}$, then $\lj \Gamma A$ and $\lj {\Gamma, x \!:\! A} B$.
\item Given $\lj \Gamma {A + B}$, then $\lj \Gamma A$ and $\lj {\Gamma} B$.
\item Given $\lj \Gamma {V =_A W}$, then $\lj \Gamma A$ and $\vj {\Gamma} V A$ and $\vj {\Gamma} W A$.
\item Given $\lj \Gamma {U\ul{C}}$, then $\lj \Gamma \ul{C}$.
\item Given $\lj \Gamma {\ul{C} \multimap \ul{D}}$, then $\lj \Gamma \ul{C}$ and $\lj \Gamma \ul{D}$.
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(f)$ independently of each other, by induction on the given derivations. 

First, by recalling the rules that define the judgement $\lj \Gamma A$ from Definition~\ref{def:judgements}, we can see that the given derivation can only end with the corresponding type formation rule or with the context conversion rule for value types.

If the given derivation ends with a type formation rule, the required derivations follow immediately from the premises of that rule.

If the given derivation ends with the context conversion rule, we apply the context conversion rule on the derivations given to us by the induction hypotheses. For example, in the case of the context conversion rule for $(a)$, the given derivation ends with
\[
\mkrule
{\lj {\Gamma_2} {\Sigma\, x \!:\! A .\, B}}
{\vdash \Gamma_1 = \Gamma_2 \quad \lj {\Gamma_1} {\Sigma\, x \!:\! A .\, B}}
\]
By using the induction hypothesis on the derivation of $\lj {\Gamma_1} {\Sigma\, x \!:\! A .\, B}$, we get derivations of $\lj {\Gamma_1} {A}$ and $\lj {\Gamma_1, x \!:\! A} {B}$. We can then use the context conversion rule with $\vdash \Gamma_1 = \Gamma_2$ on these derivations to get the required derivations of $\lj {\Gamma_2} {A}$ and $\lj {\Gamma_2, x \!:\! A} {B}$.
\end{proof}

\begin{proposition} 
\label{prop:computationtypeinversion}
The following inversion principles are valid for computation types:
\begin{enumerate}[(a)]
\item Given $\lj \Gamma {FA}$, then $\lj \Gamma A$.
\item Given $\lj \Gamma {\Sigma\, x \!:\! A .\, \ul{C}}$, then $\lj \Gamma A$ and $\lj {\Gamma, x \!:\! A} \ul{C}$.
\item Given $\lj \Gamma {\Pi\, x \!:\! A .\, \ul{C}}$, then $\lj \Gamma A$ and $\lj {\Gamma, x \!:\! A} \ul{C}$.
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(c)$ independently of each other, by induction on the given derivations. As in the proof of Proposition~\ref{prop:valuetypeinversion}, we again observe that the given derivations can only end with a corresponding type formation rule, or with a context conversion rule. Both cases are treated analogously to the proof of Proposition~\ref{prop:valuetypeinversion}.
\end{proof}

\begin{proposition}
\label{prop:valueterminversion}
The following inversion principles are valid for value terms:
\begin{enumerate}[(a)]
\item Given $\vj {\Gamma} {x} A$, then $x \!:\! B \in \Gamma$ and $\ljeq \Gamma A B$, for some value type $B$.
\item Given $\vj \Gamma {\zero} A$, then $\ljeq \Gamma A {\Nat}$.
\item Given $\vj \Gamma {\suc V} A$, then $\ljeq \Gamma A {\Nat}$ and $\vj \Gamma V \Nat$.
\item Given $\vj \Gamma {\natrec {x.A} {V_z} {y_1.y_2.V_s} V} {B}$, then $\ljeq \Gamma B {A[V/x]}$ and 

\vspace{-0.2cm}
\hfill $\vj \Gamma {V_z} {\Nat}$ and $\vj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! A[y_1/x]} {V_s} {A[\suc y_1/x]}$ and $\vj \Gamma V \Nat$.
\item[] \ldots
\item[(q)] Given $\vj \Gamma {\lambda\, x \!:\! \ul{C} .\, K} {A}$, then $\ljeq \Gamma A {\ul{C} \multimap \ul{D}}$ and $\hj {\Gamma} {z \!:\! \ul{C}} K {\ul{D}}$, 

\vspace{-0.2cm}
\hfill for some computation type $\ul{D}$ with $\lj {\Gamma} {\ul{D}}$.

\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(q)$ independently of each other, by induction on the given derivations. 

First, by recalling the rules that define the judgement $\vj \Gamma V A$ from Definition~\ref{def:judgements}, we can see that the given derivation can only end with the corresponding typing rule, or with a context and type conversion rule.

If the given derivation ends with a typing rule, the required derivations of the subterms of the given term follow immediately from the premises of that rule. Further, we prove the required definitional equations using the reflexivity of $\ljeq \Gamma A B$. 

If the given derivation ends with a context and type conversion rule, we apply the context and type conversion rule on the derivations given by the induction hypotheses.  For example, in the case of the context and type conversion rule for $(q)$, the given derivation ends with 
\[
\mkrule
{\vj {\Gamma_2} {\lambda\, z \!:\! \ul{C} .\, K} {B}}
{\vj {\Gamma_1} {\lambda\, z \!:\! \ul{C} .\, K} {A} \quad \vdash \Gamma_1 = \Gamma_2 \quad \ljeq {\Gamma_1} {A} {B}}
\]
Now, by using the induction hypothesis on the derivation of $\vj {\Gamma_1} {\lambda\, z \!:\! \ul{C} .\, K} {A}$, we get a type $\ul{D}$, and derivations of $\lj {\Gamma_1} {\ul{D}}$, $\ljeq {\Gamma_1} {A} {\ul{C} \multimap \ul{D}}$, and $\hj {\Gamma_1} {z \!:\! \ul{C}} K {\ul{D}}$. We can \linebreak then use the context and type conversion rules on these derivations, in combination with the assumed derivations of $\vdash \Gamma_1 = \Gamma_2$ and $\ljeq {\Gamma_1} {A} {B}$, to get the required derivations of $\lj {\Gamma_2} {\ul{D}}$ and $\ljeq {\Gamma_2} {B} {\ul{C} \multimap \ul{D}}$ and $\hj {\Gamma_2} {z \!:\! \ul{C}} K {\ul{D}}$.

In the induction step case for $(a)$, we further use Proposition~\ref{prop:findingvariableinequalcontexts} to show that the types assigned to $x$ in definitionally equal contexts are definitionally equal.
\end{proof}

\begin{proposition}
\label{prop:compterminversion}
The following inversion principles are valid for computation terms:
\begin{enumerate}[(a)]
\item Given $\cj \Gamma {\return V} \ul{C}$, then $\ljeq \Gamma {\ul{C}} {FA}$ and $\vj \Gamma V A$, for some value type $A$.
\item Given $\cj \Gamma {\doto M {x \!:\! A} {\ul{C}} {N}} \ul{D}$, then $\ljeq \Gamma {\ul{D}} {\ul{C}}$ and $\cj \Gamma M {FA}$ and $\cj {\Gamma, x \!:\! A} N {\ul{C}}$.
\item Given $\cj \Gamma {\langle V , M \rangle_{(x : A).\ul{C}}} {\ul{D}}$, then $\ljeq \Gamma {\ul{D}} {\Sigma\, x \!:\! A .\, \ul{C}}$ and $\vj \Gamma V A$ and $\cj \Gamma M {\ul{C}[V/x]}$.
\item Given $\cj \Gamma {\doto {M} {(x \!:\! A , z \!:\! \ul{C}_1)} {\ul{C}_2} {K}} {\ul{D}}$, then $\ljeq \Gamma {\ul{D}} {\ul{C}_2}$ and 

\vspace{-0.2cm}
\hfill $\cj \Gamma M {\Sigma\, x \!:\! A .\, \ul{C}_1}$ and $\hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}_1} K {\ul{C}_2}$.
\item Given $\cj \Gamma {\lambda\, x \!:\! A .\, M} {\ul{D}}$, then $\ljeq \Gamma {\ul{D}} {\Pi\, x \!:\! A .\, \ul{C}}$ and $\vj {\Gamma, x \!:\! A} M {\ul{C}}$, 

\vspace{-0.2cm}
\hfill for some computation type $\ul{C}$ with $\lj {\Gamma, x \!:\! A} {\ul{C}}$.
\item Given $\cj \Gamma {M(V)_{(x : A) .\, \ul{C}}} {\ul{D}}$, then $\ljeq \Gamma {\ul{D}} {\ul{C}[V/x]}$ and $\cj \Gamma M {\Pi\, x \!:\! A .\, \ul{C}}$ and $\vj \Gamma V A$.
\item Given $\cj \Gamma {\force {\ul{C}} V} {\ul{D}}$, then $\ljeq \Gamma {\ul{D}} {\ul{C}}$ and $\vj \Gamma V {U\ul{C}}$.
\item Given $\cj \Gamma {V(M)_{\ul{C}_1, \ul{C}_2}} {\ul{D}}$, then $\ljeq \Gamma {\ul{D}} {\ul{C}_2}$ and $\vj \Gamma V {\ul{C}_1 \multimap \ul{C}_2}$ and $\cj \Gamma M {\ul{C}_1}$.
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(h)$ independently of each other, by induction on the given derivations. Similarly to the proof of Proposition~\ref{prop:valueterminversion}, we again observe that the given derivation can only end with a corresponding typing rule, or with a context and type conversion rule. Both cases are treated analogously to the proof of Proposition~\ref{prop:valueterminversion}.
\end{proof}

\begin{proposition}
\label{prop:homterminversion}
The following inversion principles are valid for homomorphism terms:
\begin{enumerate}[(a)]
\item Given $\hj \Gamma {z_1 \!:\! \ul{C}} {z_2} \ul{D}$, then $\ljeq \Gamma {\ul{D}} {\ul{C}}$ and $z_1 = z_2$.
\item Given $\hj \Gamma {z \!:\! \ul{C}} {\doto K {x \!:\! A} {\ul{D}_1} {N}} \ul{D}_2$, then $\ljeq \Gamma {\ul{D}_2} {\ul{D}_1}$ and 

\vspace{-0.2cm}
\hfill $\hj \Gamma {z \!:\! \ul{C}} K {FA}$ and $\cj {\Gamma, x \!:\! A} N {\ul{D}_1}$.
\item Given $\hj \Gamma {z \!:\! \ul{C}} {\langle V , K \rangle_{(x : A).\ul{D}_1}} {\ul{D}_2}$, then $\ljeq \Gamma {\ul{D}_2} {\Sigma\, x \!:\! A .\, \ul{D}_1}$ and 

\vspace{-0.2cm}
\hfill $\vj \Gamma V A$ and $\hj \Gamma {z \!:\! \ul{C}} K {\ul{D}_1[V/x]}$.
\item Given $\hj \Gamma {z_1 \!:\! \ul{C}} {\doto {K} {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {\ul{D}_2} {L}} {\ul{D}_3}$, then $\ljeq \Gamma {\ul{D}_3} {\ul{D}_2}$ and 

\vspace{-0.2cm}
\hfill $\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma\, x \!:\! A .\, \ul{D}_1}$ and $\hj {\Gamma, x \!:\! A} {z_2 \!:\! \ul{D}_1} L {\ul{D}_2}$.
\item Given $\hj \Gamma {z \!:\! \ul{C}} {\lambda\, x \!:\! A .\, K} {\ul{D}_2}$, then $\ljeq \Gamma {\ul{D}_2} {\Pi\, x \!:\! A .\, \ul{D}_1}$ and $\hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} K {\ul{D}_1}$, 

\vspace{-0.2cm}
\hfill for some computation type $\ul{D}_1$ with $\lj {\Gamma, x \!:\! A} {\ul{D}_1}$.
\item Given $\hj \Gamma {z \!:\! \ul{C}} {K(V)_{(x : A) .\, \ul{D}_1}} {\ul{D}_2}$, then $\ljeq \Gamma {\ul{D}_2} {\ul{D}_1[V/x]}$ and 

\vspace{-0.2cm}
\hfill $\hj \Gamma {z \!:\! \ul{C}} K {\Pi\, x \!:\! A .\, \ul{D}_1}$ and $\vj \Gamma V A$.
\item Given $\hj \Gamma {z \!:\! \ul{C}} {V(K)_{\ul{D}_1, \ul{D}_2}} {\ul{D}_3}$, then $\ljeq \Gamma {\ul{D}_3} {\ul{D}_2}$ and 

\vspace{-0.2cm}
\hfill $\vj \Gamma V {\ul{D}_1 \multimap \ul{D}_2}$ and $\hj \Gamma {z \!:\! \ul{C}} K {\ul{D}_1}$.
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(g)$ independently of each other, by induction on the given derivations. Similarly to the proof of Proposition~\ref{prop:valueterminversion}, we again observe that the given derivation can  only end with a corresponding typing rule, or with a context and type conversion rule. Both cases are treated analogously to the proof of Proposition~\ref{prop:valueterminversion}.
\end{proof}

As a direct consequence of these three inversion lemmas, we can prove that the type assignment in eMLTT is unique up to definitional equations between types.

\pagebreak

\begin{proposition} \mbox{}
\label{prop:uniquenessoftypeassignement}
\begin{enumerate}[(a)]
\item Given $\vj \Gamma V A_1$ and $\vj \Gamma V A_2$, then $\ljeq \Gamma {A_1} {A_2}$.
\item Given $\cj \Gamma M \ul{C}_1$ and $\cj \Gamma M \ul{C}_2$, then $\ljeq \Gamma {\ul{C}_1} {\ul{C}_2}$.
\item Given $\hj \Gamma {z \!:\! \ul{C}} K \ul{D}_1$ and $\hj \Gamma {z \!:\! \ul{C}} K \ul{D}_2$, then $\ljeq \Gamma {\ul{D}_1} {\ul{D}_2}$.
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(c)$ simultaneously: $(a)$ by induction on the structure of $V$, $(b)$ by induction on the structure of $M$, and $(c)$ by induction on the structure of $K$. In each of these cases, we use the corresponding case of Proposition~\ref{prop:valueterminversion},~\ref{prop:compterminversion}, or~\ref{prop:homterminversion}.

For example, in the case when $V$ is a value variable $x$, the case $(a)$ of Proposition~\ref{prop:valueterminversion} gives us that $x \!:\! B \in \Gamma$, for some value type $B$, together with derivations of $\ljeq \Gamma {A_1} B$ and $\ljeq \Gamma {A_2} B$. By combining these derivations using the symmetry and transitivity rules for definitionally equal value types, we get the required derivation of $\ljeq \Gamma {A_1} {A_2}$.

As another example, in the case when $M$ is of the form $\doto {N_1} {x \!:\! A} {\ul{C}} {N_2}$, the case $(b)$ of Proposition~\ref{prop:compterminversion} gives us derivations of $\ljeq \Gamma {\ul{D}_1} {\ul{C}}$ and $\ljeq \Gamma {\ul{D}_2} {\ul{C}}$. By combining these derivations using the symmetry and transitivity rules for definitionally equal computation types, we get the required derivation of $\ljeq \Gamma {\ul{D}_1} {\ul{D}_2}$.

As a final example, in the case when $K$ is of the form $\lambda\, x \!:\! B .\, L$, the case $(e)$ of Proposition~\ref{prop:homterminversion} gives us derivations of $\ljeq \Gamma {\ul{D}_1} {\Pi\, x \!:\! B .\, \ul{D}_3}$ and $\ljeq \Gamma {\ul{D}_2} {\Pi\, x \!:\! B .\, \ul{D}_4}$, \linebreak together with derivations of $\hj {\Gamma, x \!:\! B} {z \!:\! \ul{C}} L {\ul{D}_3}$ and $\hj {\Gamma, x \!:\! B} {z \!:\! \ul{C}} L {\ul{D}_4}$, for some computation types $\ul{D}_3$ and $\ul{D}_4$. Next, by using the induction hypothesis on the latter two derivations, we get a derivation of $\ljeq {\Gamma, x \!:\! B} {\ul{D}_3} {\ul{D}_4}$. Further, by using the \linebreak congruence rule for the computational $\Pi$-type on this derivation, we get a derivation of \linebreak $\ljeq \Gamma {\Pi\, x \!:\! B .\, \ul{D}_3} {\Pi\, x \!:\! B .\, \ul{D}_4}$. Finally, by combining this derivation with the derivations of $\ljeq \Gamma {\ul{D}_1} {\Pi\, x \!:\! B .\, \ul{D}_3}$ and $\ljeq \Gamma {\ul{D}_2} {\Pi\, x \!:\! B .\, \ul{D}_4}$ using the symmetry and transitivity rules for definitionally equal computation types, we get the required derivation of $\ljeq \Gamma {\ul{D}_1} {\ul{D}_2}$.
\end{proof}


We conclude this section by showing that the judgements of well-formed expressions and definitional equations only involve well-formed contexts, well-formed types, and well-typed terms.



\begin{proposition} \mbox{}
\label{prop:wellformedcomponentsofjudgements}
\begin{enumerate}[(a)]
\item Given $\lj {\Gamma} A$, then $\vdash \Gamma$.
\item Given $\ljeq {\Gamma} {A} {B}$, then $\lj \Gamma A$ and $\lj \Gamma B$.
\item Given $\lj {\Gamma} \ul{C}$, then $\vdash \Gamma$.
\item Given $\ljeq {\Gamma} {\ul{C}} {\ul{D}}$, then $\lj \Gamma \ul{C}$ and $\lj \Gamma \ul{D}$.
\item Given $\vj {\Gamma} V A$, then $\lj \Gamma A$.
\item Given $\veq {\Gamma} V W A$, then $\vj \Gamma V A$ and $\vj \Gamma W A$.
\item Given $\cj {\Gamma} M \ul{C}$, then $\lj \Gamma \ul{C}$.
\item Given $\ceq {\Gamma} M N \ul{C}$, then $\cj \Gamma M \ul{C}$ and $\cj \Gamma N \ul{C}$.
\item Given $\hj {\Gamma} {z \!:\! \ul{C}} K \ul{D}$, then $\lj \Gamma \ul{C}$ and $\lj \Gamma \ul{D}$.
\item Given $\heq {\Gamma} {z \!:\! \ul{C}} K L \ul{D}$, then $\hj {\Gamma} {z \!:\! \ul{C}} K \ul{D}$ and $\hj {\Gamma} {z \!:\! \ul{C}} L \ul{D}$.
\end{enumerate}
\end{proposition}

\begin{proof}
We prove $(a)$--$(j)$ simultaneously, by induction on the given derivations. Below we sketch the proofs of four cases that demonstrate the use of the weakening and substitution theorems, the inversion lemmas from Proposition~\ref{prop:valuetypeinversion}, and the well-formedness assumptions for type annotations.

\vspace{0.2cm}

\noindent \textbf{Typing rule for value variables:}
In this case, the given derivation ends with
\[
\mkrule
{\vj {\Gamma_1, x \!:\! A, \Gamma_2} {x} {A}}
{\vdash \Gamma_1, x \!:\! A, \Gamma_2}
\]
and we are required to construct a derivation of $\lj {\Gamma_1, x \!:\! A, \Gamma_2} A$.


First, we use Proposition~\ref{prop:wellformedtypesinwellformedcontexts} to get a derivation of $\lj {\Gamma_1} A$. Next, we use $(c)$ of Theorem~\ref{thm:weakening} on this derivation of $\lj {\Gamma_1} A$ to get a derivation of  $\lj {\Gamma_1, x \!:\! A} A$. 

Finally, we turn this derivation of $\lj {\Gamma_1, x \!:\! A} A$ into the derivation of $\lj {\Gamma_1, x \!:\! A, \Gamma_2} A$ by induction on the length of $\Gamma_2$, using $(c)$ of Theorem~\ref{thm:weakening}, and by observing that in each of the cases the last rule used in the derivation of $\vdash \Gamma_1, x \!:\! A, \Gamma_2$ has to be the context extension rule.

\vspace{0.2cm}

\noindent \textbf{Typing rule for forcing a thunked computation:}
In this case, the given derivation ends with
\[
\mkrule
{\cj \Gamma {\force {\ul{C}} V} {\ul{C}}}
{\vj \Gamma V U\ul{C}}
\]
and we are required to construct a derivation of $\lj \Gamma \ul{C}$.

We observe that by using $(e)$ on the derivation of $\vj \Gamma V U\ul{C}$, we get a derivation $\lj {\Gamma} U\ul{C}$. As a result, by using Proposition~\ref{prop:valuetypeinversion} on this derivation of $\lj {\Gamma} U\ul{C}$, we get the required derivation of $\lj {\Gamma} \ul{C}$.

\vspace{0.2cm}

\noindent \textbf{Typing rule for computational pairing:}
In this case, the given derivation ends with
\[
\mkrule
{\cj {\Gamma} {\langle W , M \rangle_{(x : A).\, \ul{C}}} {\Sigma \, x \!:\! A .\, \ul{C}}}
{\vj {\Gamma} W B \quad \lj {\Gamma, x \!:\! A} {\ul{C}} \quad \cj {\Gamma} M {\ul{C}[W/y]}}
\]
and we are required to construct derivations of $\vdash \Gamma$ and $\lj \Gamma {\Sigma \, x \!:\! A .\, \ul{C}}$.


We observe that by using the derivation of $\lj {\Gamma, x \!:\! A} {\ul{C}}$, we can construct the required derivation of $\lj \Gamma {\Sigma \, x \!:\! A .\, \ul{C}}$ simply by using the corresponding type formation rule.

\vspace{0.2cm}

\noindent \textbf{Replacement rule for computation terms:}
In this case, the given derivation ends with
\[
\mkrule
{\ceq {\Gamma_1, \Gamma_2[V_1/x]} {M[V_1/x]} {M[V_2/x]} {\ul{C}[V_1/x]}}
{\cj {\Gamma_1, x \!:\! A, \Gamma_2} M {\ul{C}} \quad \veq {\Gamma_1} {V_1} {V_2} {A}}
\]
and we are required to construct derivations of $\cj {\Gamma_1, \Gamma_2[V_1/x]} {M[V_1/x]} {\ul{C}[V_1/x]}$ and \linebreak$\cj {\Gamma_1, \Gamma_2[V_1/x]} {M[V_2/x]} {\ul{C}[V_1/x]}$.

First, we use $(g)$ on the given derivation of $\cj {\Gamma_1, x \!:\! A, \Gamma_2} M {\ul{C}}$ to get derivations of \linebreak $\vdash \Gamma_1, x \!:\! A, \Gamma_2$ and $\lj {\Gamma_1, x \!:\! A, \Gamma_2} {\ul{C}}$. 

Next, we use $(f)$ on the given derivation of $\veq {\Gamma_1} {V_1} {V_2} {A}$ to get derivations of $\vj {\Gamma_1} {V_1} {A}$ and $\vj {\Gamma_1} {V_2} {A}$. 

Further, we use $(i)$ of Theorem~\ref{thm:substitution} on the derivations of $\cj {\Gamma_1, y \!:\! A, \Gamma_2} M {\ul{C}}$, $\vj {\Gamma_1} {V_1} {A}$, and $\vj {\Gamma_1} {V_2} {A}$ to get derivations of $\cj {\Gamma_1, \Gamma_2[V_1/x]} {M[V_1/x]} {\ul{C}[V_1/x]}$ and $\cj {\Gamma_1, \Gamma_2[V_2/x]} {M[V_2/x]} {\ul{C}[V_2/x]}$. 

Finally, we construct the required derivation of $\cj {\Gamma_1, \Gamma_2[V_1/x]} {M[V_2/x]} {\ul{C}[V_1/x]}$ by combining the context and type conversion rule for computation terms with replacement rules for value contexts and computation types, as shown below
\[
\mkrule
{\cj {\Gamma_1, \Gamma_2[V_1/x]} {M[V_2/x]} {\ul{C}[V_1/x]}}
{
(1)
\quad
\mkrule
{\ljeq {} {\Gamma_1, \Gamma_2[V_2/x]} {\Gamma_1, \Gamma_2[V_1/x]}}
{(2)}
\quad
\mkrule
{\ljeq {\Gamma_1, \Gamma_2[V_2/x]} {\ul{C}[V_2/x]} {\ul{C}[V_1/x]}}
{(3)}
}
\]
where $(1)$ is given by
\[
\cj {\Gamma_1, \Gamma_2[V_2/x]} {M[V_2/x]} {\ul{C}[V_2/x]}
\]
and $(2)$ by
\[
\mkrule
{\ljeq {} {\Gamma_1, \Gamma_2[V_2/x]} {\Gamma_1, \Gamma_2[V_1/x]}}
{
\mkrule
{\ljeq {} {\Gamma_1, x \!:\! A, \Gamma_2} {\Gamma_1, x \!:\! A, \Gamma_2}}
{\vdash {\Gamma_1, x \!:\! A, \Gamma_2}}
\quad 
\mkrule
{\veq {\Gamma_1} {V_2} {V_1} {A}}
{\veq {\Gamma_1} {V_1} {V_2} {A}}
}
\]
and $(3)$ by
\[
\mkrule
{\ljeq {\Gamma_1, \Gamma_2[V_2/x]} {\ul{C}[V_2/x]} {\ul{C}[V_1/x]}}
{
\mkrule
{\ljeq {\Gamma_1, x \!:\! A, \Gamma_2} {\ul{C}} {\ul{C}}}
{\lj {\Gamma_1, x \!:\! A, \Gamma_2} {\ul{C}}}
\quad
\mkrule
{\veq {\Gamma_1} {V_2} {V_1} {A}}
{\veq {\Gamma_1} {V_1} {V_2} {A}}
}
\]

\end{proof}

\begin{proposition}
Given $\vdash {\Gamma_1} =  \Gamma_2$, then $\vdash \Gamma_1$ and $\vdash \Gamma_2$.
\end{proposition}

\begin{proof}
We prove this proposition by induction on the derivation of $\vdash {\Gamma_1} =  \Gamma_2$. 

In the case of the congruence rule for context extension, when the equation is of the form $\vdash {\Gamma_1, x \!:\! A} = \Gamma_2, x \!:\! B$, we use $(b)$ of Proposition~\ref{prop:wellformedcomponentsofjudgements} to get derivations of $\lj {\Gamma_1} A$ and $\lj {\Gamma_1} B$ from the derivation of $\ljeq {\Gamma_1} A B$. We then use the context conversion rule on $\lj {\Gamma_1} B$ to get a derivation of $\lj {\Gamma_2} B$. Finally, we use the context extension rule on $\lj {\Gamma_1} A$ and $\lj {\Gamma_2} B$ to get the required derivations of $\lj {} {\Gamma_1, x \!:\! A}$ and $\lj {} {\Gamma_2, x \!:\! B}$.
\end{proof}


\section{Derivable elimination forms}
\label{sect:derivableeliminationforms}

In this section we show how to eliminate value types into computation and homomorphism terms. In addition, we show that the corresponding $\beta$- and $\eta$-equations hold.


Recall that the type of natural numbers, the value $\Sigma$-type, the empty type, the coproduct type,  and propositional equality are only eliminated into value terms in eMLTT. While being able to eliminate these types into value terms is necessary to accommodate effect-free programs on which eMLTT's types could depend on, it is also desirable to be able to eliminate these types into computation and homomorphism terms, e.g., to use primitive recursion in effectful programs.
Below we show that such elimination forms are derivable using thunking and forcing for computation terms, and homomorphic lambda abstraction and function application for homomorphism terms.

First, we show how to derive the elimination forms for computation terms.

\begin{definition} The \emph{computation term variant of}
\label{def:derivablecomputationtermvariantsofeliminators}
\begin{itemize}
\item \emph{primitive recursion} is defined as
\[
\begin{array}{c}
\hspace{-7.5cm} \natrec {x.\,\ul{C}} {M_z} {y_1.\, y_2.\, M_s} {V} \defeq 
\\[1mm]
\hspace{3cm} \force {\ul{C}[V/x]} (\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {V})
\end{array}
\]
\item \emph{pattern-matching} is defined as
\[
\begin{array}{c}
\hspace{-7cm} \pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\, \ul{C}} M  \defeq
\\[1mm]
\hspace{3cm} \force {\ul{C}[V/y]} (\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\, U\ul{C}} {\thunk M})
\end{array}
\]
\item \emph{empty case analysis} is defined as
\[
\absurd {x.\,\ul{C}} V \defeq \force {\ul{C}[V/x]} (\absurd {x.\,U\ul{C}} V)
\]
\item \emph{binary case analysis} is defined as
\[
\begin{array}{c}
\hspace{-3.6cm} \case {V} {y.\, \ul{C}} {\inl {\!} {\!\!(x_1 \!:\! A_1)} \mapsto M} {\inr {\!} {\!\!(x_2 \!:\! A_2)} \mapsto N} \defeq
\\[1mm]
\hspace{2cm} \force {\ul{C}[V/y]} (\case {V} {y.\, U\ul{C}} {\inl {\!} {\!\!(x_1 \!:\! A_1)} \mapsto \thunk M} {
\\[-1mm]
\hspace{7.15cm} \inr {\!} {\!\!(x_2 \!:\! A_2)} \mapsto \thunk N})
\end{array}
\]
\item \emph{elimination of propositional equality} is defined as
\[
\begin{array}{c}
\hspace{-6cm} \pathind A {x_1.\, x_2.\, x_3.\, \ul{C}} {y.\, M} {V_1} {V_2} {V_p} \defeq 
\\[1mm]
\hspace{0.9cm} \force {\ul{C}[V_1/x_1][V_2/x_2][V_p/x_3]} (\pathind A {x_1.\, x_2.\, x_3.\, U\ul{C}} {y.\, \thunk M} {V_1} {V_2} {V_p})
\end{array}
\]
\end{itemize}
\end{definition}

Next, we show that these derived elimination forms are well-typed. 

\begin{proposition}
The following typing rules are derivable for the computation term variant of:
\begin{itemize}
\item primitive recursion
\[
\mkrule
{\cj \Gamma {\natrec {x.\,\ul{C}} {M_z} {y_1.\, y_2.\, M_s} {V}} {\ul{C}[V/x]}}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! \Nat} {\ul{C}} \quad \vj \Gamma V \Nat 
\\[-1mm]
\cj \Gamma {M_z} {\ul{C}[\zero/x]} \quad \cj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! U\ul{C}[y_1/x]} {M_z} {\ul{C}[\suc y_1/x]}
\end{array}
}
\]
\item pattern-matching
\[
\mkrule
{\cj \Gamma {\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\,\ul{C}} M} {\ul{C}[V/y]}}
{
\begin{array}{c}
\lj {\Gamma, y \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} {\ul{C}}
\\[-1mm]
\vj \Gamma V {\Sigma \, x_1 \!:\! A_1 .\, A_2} \quad \cj {\Gamma, x_1 \!:\! A_1, x_2 \!:\! A_2} {M} {\ul{C}[\langle x_1 , x_2 \rangle /y]}
\end{array}
}
\]
\item empty case analysis
\[
\mkrule
{\cj \Gamma {\absurd {x.\,\ul{C}} V} {\ul{C}[V/x]}}
{
\vj {\Gamma} V 0 \quad \lj {\Gamma, x \!:\! 0} \ul{C}
}
\]
\item binary case analysis
\[
\mkrule
{\cj \Gamma {\case {V} {y.\, \ul{C}} {\inl {\!} {\!\!(x_1 \!:\! A_1)} \mapsto M} {\inr {\!} {\!\!(x_2 \!:\! A_2)} \mapsto N}} {\ul{C}[V/y]}}
{
\begin{array}{c}
\lj {\Gamma, y \!:\! A_1 + A_2} \ul{C} \quad \vj \Gamma V {A_1 + A_2} 
\\[-1mm]
\cj {\Gamma, x_1 \!:\! A_1} {M} {\ul{C}[\inl {A_1 + A_2} x_1/y]} \quad \cj {\Gamma, x_2 \!:\! A_2} {N} {\ul{C}[\inr {A_1 + A_2} x_2/y]}
\end{array}
}
\]
\item elimination of propositional equality 
\[
\mkrule
{\cj \Gamma {\pathind A {x_1.\, x_2.\, x_3.\, \ul{C}} {y.\, M} {V_1} {V_2} {V_p}} {\ul{C}[V_1/x_1][V_2/x_2][V_p/x_3]}}
{
\begin{array}{c}
\lj \Gamma A \quad \lj {\Gamma, x_1 \!:\! A, x_2 \!:\! A, x_3 \!:\! x_1 =_A x_2} {\ul{C}} \quad \vj \Gamma {V_1} A \quad \vj \Gamma {V_2} A 
\\[-1mm]
\vj \Gamma {V_p} {V_1 =_A V_2} \quad \cj {\Gamma, y \!:\! A} {M} {\ul{C}[y/x_1][y/x_2][\refl A y/x_3]}
\end{array}
}
\]
\end{itemize}
\end{proposition}

\begin{proof}
We prove this proposition by constructing the corresponding typing derivations. 

For example, the typing derivation for primitive recursion is given by
\[
\mkrule
{\cj \Gamma {\natrec {x.\,\ul{C}} {M_z} {y_1.\, y_2.\, M_s} {V}} {\ul{C}[V/x]}}
{
\mkrule
{\cj \Gamma {\force {\ul{C}} (\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {V})} {\ul{C}[V/x]}}
{
\mkrule
{\vj \Gamma {\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {V}} {U\ul{C}[V/x]}}
{
\mkrule
{\lj {\Gamma, x \!:\! \Nat} {U\ul{C}}}
{\lj {\Gamma, x \!:\! \Nat} {\ul{C}}}
\quad
\vj \Gamma V \Nat
\quad
(1)
\quad
(2)
}
}
}
\]
where $(1)$ is given by
\[
\mkrule
{\vj \Gamma {\thunk M_z} {U\ul{C}[\zero/x]}}
{\cj \Gamma {M_z} {\ul{C}[\zero/x]}}
\]
and $(2)$ by
\[
\mkrule
{\vj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! U\ul{C}[y_1/x]} {\thunk M_z} {U\ul{C}[\suc y_1/x]}}
{\cj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! U\ul{C}[y_1/x]} {M_z} {\ul{C}[\suc y_1/x]}}
\]
Derivations of the other typing rules listed above are constructed similarly.
\end{proof}

We finish our discussion about these derived elimination forms by proving that they satisfy computation term variants of the $\beta$- and $\eta$-equations given in Definition~\ref{def:judgements}.

\begin{proposition}
\label{prop:derivablecomputationtermvariantsofeliminatorsequations}
The following $\beta$- and $\eta$-equations are derivable for the computation term variant of:
\begin{itemize}
\item primitive recursion
\[
\mkrule
{\ceq \Gamma {\natrec {x.\,\ul{C}} {M_z} {y_1.\,y_2.\,M_s} {\zero}} {M_z} {\ul{C}[\zero/x]}}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! \Nat} {\ul{C}} 
\\[-1mm]
\cj \Gamma {M_z} {\ul{C}[\zero/x]} \quad \cj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! U\ul{C}[y_1/x]} {M_s} {\ul{C}[\suc y_1/x]}
\end{array}
}
\]
\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\natrec {x.\,\ul{C}} {M_z} {y_1.\,y_2.\,M_s} {\suc V}} 
\\
& = & {M_s[V/y_1][\thunk (\natrec {x.\ul{C}} {M_z} {y_1.\,y_2.\,M_s} {V})/y_2]} : {\ul{C}[\suc V/x]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, x \!:\! \Nat} \ul{C} \quad \vj \Gamma V \Nat 
\\[-1mm]
\cj \Gamma {M_z} {\ul{C}[\zero/x]} \quad \cj {\Gamma, y_1 \!:\! \Nat, y_2 \!:\! U\ul{C}[y_1/x]} {M_s} {\ul{C}[\suc y_1/x]}
\end{array}
}
\]
\item pattern-matching
\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\pmatch {\langle V_1 , V_2 \rangle} {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\,\ul{C}} M} 
\\
& = & {M[V_1/x_1][V_2/x_2]} : {\ul{C}[\langle V_1 , V_2 \rangle/y]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} \ul{C}
\\[-1mm]
\vj \Gamma {V_1} {A_1} \quad \vj \Gamma {V_2} {A_2[V_1/x_1]}  \quad \cj {\Gamma, x_1 \!:\! A_1, x_2 \!:\! A_2} {M} {\ul{C}[\langle x_1 , x_2 \rangle /y]}
\end{array}
}
\]

\[
\mkrule
{\veq \Gamma {\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y_1.\,\ul{C}} {M[{\langle x_1 , x_2 \rangle}/y_2]}} {M[V/y_2]} {\ul{C}[V/y_1]}}
{
\begin{array}{c}
\lj \Gamma {A_1} \quad \lj {\Gamma, x_1 \!:\! A_1} {A_2} \quad \vj \Gamma V {\Sigma \, x_1 \!:\! A_1 .\, A_2}
\\[-1mm]
\lj {\Gamma, y_1 \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} \ul{C} \quad \cj {\Gamma, y_2 \!:\! \Sigma \, x_1 \!:\! A_1 .\, A_2} {M} {\ul{C}[y_2/y_1]}
\end{array}
}
\]
\item empty case analysis
\[
\mkrule
{\ceq \Gamma {\absurd {x.\, \ul{C}} V} {M[V/x]} {\ul{C}[V/x]}}
{\lj {\Gamma, x \!:\! 0} \ul{C} \quad \vj \Gamma V 0 \quad \cj {\Gamma, x \!:\! 0} M \ul{C}}
\]
\item binary case analysis
\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\case {(\inl {A_1 + A_2} V)} {y.\, \ul{C}} {\inl {\!} {\!\!(x_1 \!:\! A_1)} \mapsto M} {\inr {\!} {\!\!(x_2 \!:\! A_2)} \mapsto N}} 
\\
& = & {M[V/x_1]} : {\ul{C}[\inl {A_1 + A_2} V/y]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y \!:\! A_1 + A_2} \ul{C} \quad \vj \Gamma V {A_1} 
\\[-1mm]
\vj {\Gamma, x_1 \!:\! A_1} {M} {\ul{C}[\inl {A_1 + A_2} x_1/y]} \quad \cj {\Gamma, x_2 \!:\! A_2} {N} {\ul{C}[\inr {A_1 + A_2} x_2/y]}
\end{array}
}
\]

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\case {(\inr {A_1 + A_2} V)} {y.\, \ul{C}} {\inl {\!} {\!\!(x_1 \!:\! A_1)} \mapsto M} {\inr {\!} {\!\!(x_2 \!:\! A_2)} \mapsto N}} 
\\
& = & {N[V/x_2]} : {\ul{C}[\inr {A_1 + A_2} V/y]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y \!:\! A_1 + A_2} \ul{C} \quad \vj \Gamma V {A_2} 
\\[-1mm]
\vj {\Gamma, x_1 \!:\! A_1} {M} {\ul{C}[\inl {A_1 + A_2} x_1/y]} \quad \cj {\Gamma, x_2 \!:\! A_2} {N} {\ul{C}[\inr {A_1 + A_2} x_2/y]}
\end{array}
}
\]

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\mathtt{case~} V \mathtt{~of}_{y_1.\,\ul{C}} \mathtt{~} ({\inl {\!} {\!\!(x_1 \!:\! A_1)} \mapsto M[\inl {A_1 + A_2} x_1/y_2]} , }
\\[-1mm]
&& \hspace{2.7cm} {\inr {\!} {\!\!(x_2 \!:\! A_2)} \mapsto M[\inr {A_1 + A_2} x_2/y_2]}) 
\\
& = & {M[V/y_2]} : {\ul{C}[V/y_1]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y_1 \!:\! A_1 + A_2} \ul{C}
\quad
\vj \Gamma V {A_1 + A_2} \quad \cj {\Gamma, y_2 \!:\! A_1 + A_2} {M} {\ul{C}[y_2/y_1]}
\end{array} 
}
\]
\item elimination of propositional equality
\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\pathind A {x_1.\, x_2.\, x_3.\, \ul{C}} {y.\, M} {V} {V} {\refl A V}} 
\\
& = & {M[V/y]} : {\ul{C}[V/x_1][V/x_2][\refl A V/x_3]}
\end{array}
}
{
\begin{array}{c}
\lj \Gamma A \quad \lj {\Gamma, x_1 \!:\! A, x_2 \!:\! A, x_3 \!:\! x_1 =_A x_2} {\ul{C}}
\\[-1mm]
\vj \Gamma {V} A \quad \cj {\Gamma, y \!:\! A} {M} {\ul{C}[y/x_1][y/x_2][\refl A y/x_3]}
\end{array}
}
\]
\end{itemize}
\end{proposition}

\begin{proof}
We prove this proposition by using the corresponding $\beta$- and $\eta$-equations for the value term variants of these elimination forms, together with the equations for thunking and forcing. 

For example, the first $\beta$-equation for primitive recursion is proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \,\vdash\,\, & \natrec {x.\,\ul{C}} {M_z} {y_1.\, y_2.\, M_s} {\zero}
\\
=\,\, & \force {\ul{C}[\zero/x]} \big(\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {\zero}\big)
\\
=\,\, & \force {\ul{C}[\zero/x]} (\thunk M_z)
\\
=\,\, & M_z \,:\, \ul{C}[\zero/x]
\end{align*}
\end{fleqn}
%
and the second $\beta$-equation as follows:
\begin{fleqn}[0.1cm]
\begin{align*}
\Gamma \,\vdash\,\, & \natrec {x.\,\ul{C}} {M_z} {y_1.\, y_2.\, M_s} {\suc V}
\\
=\,\, & \force {\ul{C}[\suc V/x]} \big(\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {\suc V}\big)
\\
=\,\, & \force {\ul{C}[\suc V/x]} \big((\thunk M_s)[V/y_1]
\\[-2mm]
& \hspace{5.08cm} [\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {V}/y_2]\big)
\\
=\,\, & \force {\ul{C}[\suc V/x]} \big(\thunk (M_s[V/y_1]
\\[-2mm]
& \hspace{4.93cm} [\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {V}/y_2])\big)
\\
=\,\, & M_s[V/y_1][\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {V}/y_2]
\\
=\,\, & M_s[V/y_1]
\\[-2mm]
& \hspace{0.5cm} [\thunk \big(\force {\ul{C}[V/x]} \big(\natrec {x.\,U\ul{C}} {\thunk M_z} {y_1.\, y_2.\, \thunk M_s} {V}\big)\big)/y_2]
\\
=\,\, & M_s[V/y_1][\thunk (\natrec {x.\,\ul{C}} {M_z} {y_1.\, y_2.\, M_s} {V})/y_2] \,:\, \ul{C}[\suc V/x]
\end{align*}
\end{fleqn}
%

\vspace{0.3cm}

As another example, the $\eta$-equation for pattern-matching is proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \,\vdash\,\, & \pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\,\ul{C}} {M[{\langle x_1 , x_2 \rangle}/y]}
\\
=\,\, & \force {\ul{C}[V/x]} \big(\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\, \ul{C}} {(\thunk M[{\langle x_1 , x_2 \rangle}/y])}\big)
\\
=\,\, & \force {\ul{C}[V/x]} \big(\pmatch V {(x_1 \!:\! A_1, x_2 \!:\! A_2)} {y.\, \ul{C}} {(\thunk M)[{\langle x_1 , x_2 \rangle}/y]}\big)
\\
=\,\, & \force {\ul{C}[V/x]} ((\thunk M)[V/y])
\\
=\,\, & \force {\ul{C}[V/x]} (\thunk M[V/y])
\\
=\,\, & M[V/y] \,:\, \ul{C}[V/y]
\end{align*}
\end{fleqn}
The other $\beta$- and $\eta$-equations listed above are proved similarly.
\end{proof}

Next, we show how to derive the elimination forms for homomorphism terms.


\pagebreak

\begin{definition} The \emph{homomorphism term variant of}
\begin{itemize}
\item \emph{primitive recursion} is defined as
\[
\begin{array}{c}
\hspace{-8.5cm} \natrec {\ul{C}} {K_z} {y .\, K_s} {V} \defeq 
\\[1mm]
\hspace{3cm} \big(\natrec {x_1.\,\ul{C} \,\multimap\, \ul{C}} {\lambda\, z \!:\! \ul{C} .\, K_z} {y.\, x_2.\, \lambda\, z \!:\! \ul{C} .\, K_s[x_2\, z/z]} {V}\big)\,\, z
\end{array}
\]
given that $FCV(K_z) = FCV(K_s) = z$, and where $x_1$ and $x_2$ are chosen fresh;
\item \emph{pattern-matching} is defined as
\[
\begin{array}{c}
\hspace{-6.5cm} \pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {y_3.\, \ul{C} , y_4 .\, \ul{D}} K \defeq 
\\[1mm]
\hspace{1.4cm} \big(\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {x.\, \ul{C}[x/y_3] \,\multimap\, \ul{D}[x/y_4]} {(\lambda\, z \!:\! \ul{C}[\langle y_1 , y_2 \rangle/y_3] .\, K)\big) \,\, z}
\end{array}
\]
given that $FCV(K) = z$, and where $x$ is chosen fresh;
\item \emph{empty case analysis} is defined as
\[
\absurd {y_1.\,\ul{C},y_2.\,\ul{D}} {V} \defeq \big(\absurd {x.\,\ul{C}[x/y_1] \,\multimap\, \ul{D}[x/y_2]} V\big)\,\, z
\]
where $x$ is chosen fresh;
\item \emph{binary case analysis} is defined as
\[
\begin{array}{c}
\hspace{-3.2cm} \case {V} {y_1.\, \ul{C},y_2.\, \ul{D}} {\inl {\!} {\!\!(y_3 \!:\! A)} \mapsto K} {\inr {\!} {\!\!(y_4 \!:\! B)} \mapsto L} \defeq
\\[1mm]
\hspace{-0.09cm} \big(\case {V} {x .\, \ul{C}[x/y_1] \,\multimap\, \ul{D}[x/y_2]} {\inl {\!} {\!\!(y_3 \!:\! A)} \mapsto \lambda\, z \!:\! \ul{C}[\inl {A + B} y_3/y_1] .\, K} {
\\[-1mm]
\hspace{5.25cm} \inr {\!} {\!\!(y_4 \!:\! B)} \mapsto \lambda\, z \!:\! \ul{C}[\inr {A + B} y_4/y_1] .\, L} \big) \,\, z
\end{array}
\]
given that $FCV(K) = FCV(L) = z$, and where $x$ is chosen fresh; and 
\item \emph{elimination of propositional equality} is defined as
\[
\begin{array}{c}
\hspace{-3.6cm} \pathind A {y_1.\, y_2.\, y_3.\, \ul{C} , y_4.\, y_5.\, y_6.\, \ul{D}} {y_7.\, K} {V_1} {V_2} {V_p} \defeq 
\\[1mm]
\hspace{1cm} \big(\pathind A {x_1.\, x_2.\, x_3.\, \ul{C}[x_1/y_1][x_2/y_2][x_3/y_3] \multimap \ul{D}[x_1/y_4][x_2/y_5][x_3/y_6]} {
\\[-1mm]
\hspace{2.2cm} y_7 .\, \lambda\, z \!:\! \ul{C}[y_7/y_1][y_7/y_2][\refl A y_7/y_3] .\, K} {V_1} {V_2} {V_p} \big)\,\, z_2
\end{array}
\]
given that $FCV(K) = z$, and where $x_1$, $x_2$, and $x_3$ are chosen fresh.
\end{itemize}
\end{definition}

\pagebreak

\begin{proposition}
The following typing rules are derivable for the homomorphism term variant of:
\begin{itemize}
\item primitive recursion
\[
\mkrule
{\hj \Gamma {z \!:\! \ul{C}} {\natrec {\ul{C}} {K_z} {y .\, K_s} {V}} {\ul{C}}}
{
\lj {\Gamma} {\ul{C}} \quad \vj \Gamma V \Nat 
\quad
\hj \Gamma {z \!:\! \ul{C}} {K_z} {\ul{C}} \quad \hj {\Gamma, y \!:\! \Nat} {z \!:\! \ul{C}} {K_s} {\ul{C}}
}
\]
\item pattern-matching
\[
\mkrule
{\hj \Gamma {z \!:\! \ul{C}[V/y_3]} {\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {y_3.\, \ul{C} , y_4 .\, \ul{D}} K} {\ul{D}[V/y_4]}}
{
\begin{array}{c}
\lj {\Gamma, y_3 \!:\! \Sigma \, y_1 \!:\! A .\, B} {\ul{C}} \quad \lj {\Gamma, y_4 \!:\! \Sigma \, y_1 \!:\! A .\, B} {\ul{D}}
\\[-1mm]
\vj \Gamma V {\Sigma \, y_1 \!:\! A .\, B} \quad \hj {\Gamma, y_1 \!:\! A, y_2 \!:\! B} {z \!:\! \ul{C}[\langle y_1 , y_2 \rangle /y_3]} {K} {\ul{D}[\langle y_1 , y_2 \rangle /y_4]}
\end{array}
}
\]
\item empty case analysis
\[
\mkrule
{\hj \Gamma {z \!:\! \ul{C}[V/y_1]} {\absurd {y_1.\,\ul{C},y_2.\,\ul{D}} V} {\ul{D}[V/y_2]}}
{
\vj {\Gamma} V 0 \quad \lj {\Gamma, y_1 \!:\! 0} \ul{C} \quad \lj {\Gamma, y_2 \!:\! 0} \ul{D}
}
\]
\item binary case analysis
\[
\mkrule
{
\begin{array}{c}
\hspace{-1.5cm}\Gamma \vertbar {z \!:\! \ul{C}[V/y_1]} \vdash \mathtt{case~} V \mathtt{~of}_{y_1.\, \ul{C},y_2.\, \ul{D}} \mathtt{~} (\inl {\!} {\!\!(y_3 \!:\! A)} \mapsto K , 
\\[-1mm]
\hspace{6.24cm} \inr {\!} {\!\!(y_4 \!:\! B)} \mapsto L) : \ul{D}[V/y_2]
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y_1 \!:\! A + B} \ul{C} \quad \lj {\Gamma, y_2 \!:\! A + B} \ul{D}\quad \vj \Gamma V {A + B} 
\\[-1mm]
\hj {\Gamma, y_3 \!:\! A} {z \!:\! \ul{C}[\inl {A + B} y_3/y_1]} {K} {\ul{D}[\inl {A + B} y_3/y_2]} 
\\[-1mm]
\hj {\Gamma, y_4 \!:\! B} {z \!:\! \ul{C}[\inr {A + B} y_4/y_1]} {L} {\ul{D}[\inr {A + B} y_4/y_2]}
\end{array}
}
\]
\item elimination of propositional equality 
\[
\mkrule
{
\begin{array}{c}
\hspace{-8cm} \Gamma \vertbar {z \!:\! \ul{C}[V_1/y_1][V_2/y_2][V_p/y_3]} \vdash 
\\[-1mm]
\hspace{0.5cm} {\pathind A {y_1.\, y_2.\, y_3.\, \ul{C} , y_4.\, y_5.\, y_6.\, \ul{D}} {y_7.\, K} {V_1} {V_2} {V_p}} 
\\[-1mm]
\hspace{8.8cm} : {\ul{D}[V_1/y_4][V_2/y_5][V_p/y_6]}
\end{array}
}
{
\begin{array}{c}
\lj \Gamma A \quad \lj {\Gamma, y_1 \!:\! A, y_2 \!:\! A, y_3 \!:\! y_1 =_A y_2} {\ul{C}} \quad \lj {\Gamma, y_4 \!:\! A, y_5 \!:\! A, y_6 \!:\! y_4 =_A y_5} {\ul{D}} 
\\[-1mm]
\vj \Gamma {V_1} A \quad \vj \Gamma {V_2} A \quad \vj \Gamma {V_p} {V_1 =_A V_2}
\\[-1mm]
\hj {\Gamma, y_7 \!:\! A} {z \!:\! \ul{C}[y_7/y_1][y_7/y_2][\refl A y_7/y_3]} {K} {\ul{D}[y_7/y_4][y_7/y_5][\refl A y_7/y_6]}
\end{array}
}
\]
\end{itemize}
\end{proposition}

\begin{proof}
We prove this proposition by constructing the corresponding typing derivations. 

For example, the typing derivation for the homomorphism term variant of pattern-matching is constructed as follows:
\[
\mkrule
{\hj \Gamma {z \!:\! \ul{C}[V/y_3]} {\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {y_3.\, \ul{C} , y_4 .\, \ul{D}} K} {\ul{D}[V/y_4]}}
{
\mkrule
{
\begin{array}{c}
\hspace{-11.5cm} \Gamma \vertbar {z \!:\! \ul{C}[V/y_3]} \vdash 
\\[-1mm]
\hspace{0.5cm} {\big(\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {x.\, \ul{C}[x/y_3] \,\multimap\, \ul{D}[x/y_4]} {(\lambda\, z \!:\! \ul{C}[\langle y_1 , y_2 \rangle/y_3] .\, K)}\big) \,\, z} : {\ul{D}[V/y_4]}
\end{array}
}
{
(1)
\qquad\qquad\qquad
\mkrule
{\hj \Gamma {z \!:\! \ul{C}[V/y_3]} {z} {\ul{C}[V/y_3]}}
{
\mkrule
{\lj \Gamma {\ul{C}[V/y_3]}}
{\vj \Gamma V {\Sigma\, y_1 \!:\! A .\, B} \quad \lj {\Gamma, y_3 \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{C}}}
}
}
}
\]
where $(1)$ is given by
\[
\mkrule
{
\begin{array}{c}
\hspace{-2cm} \Gamma \vdash {\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {x.\, \ul{C}[x/y_3] \,\multimap\, \ul{D}[x/y_4]} {(\lambda\, z \!:\! \ul{C}[\langle y_1 , y_2 \rangle/y_3] .\, K)}} 
\\[-1mm]
\hspace{9.7cm} : {\ul{C}[V/y_3] \,\multimap\, \ul{D}[V/y_4]}
\end{array}
}
{
\vj \Gamma V {\Sigma \, y_1 \!:\! A .\, B} \quad (2) \quad (3)
}
\]
and $(2)$ by
\[
\mkrule
{\lj {\Gamma, x \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{C}[x/y_3] \,\multimap\, \ul{D}[x/y_4]}}
{
\mkrule
{\lj {\Gamma, x \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{C}[x/y_3]}}
{
\mkrule
{\lj {\Gamma, x \!:\! \Sigma\, y_1 \!:\! A .\, B, y_3 \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{C}} \quad (4)}
{\lj {\Gamma, y_3 \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{C}} \quad 
\mkrule
{x \not\in V\!ars(\Gamma) \cup \{y_3\}}
{x \text{~is chosen fresh}}}
}
\quad
\mkrule
{\lj {\Gamma, x \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{D}[x/y_4]}}
{
\mkrule
{\lj {\Gamma, x \!:\! \Sigma\, y_1 \!:\! A .\, B, y_4 \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{D}} \quad (4)}
{\lj {\Gamma, y_4 \!:\! \Sigma\, y_1 \!:\! A .\, B} {\ul{D}} \quad 
\mkrule
{x \not\in V\!ars(\Gamma) \cup \{y_4\}}
{x \text{~is chosen fresh}}
}
}
}
\]
and $(3)$ by
\[
\mkrule
{\vj {\Gamma, y_1 \!:\! A , y_2 \!:\! B} {\lambda\, z \!:\! \ul{C}[\langle y_1 , y_2 \rangle/y_3] .\, K} {\ul{C}[\langle y_1 , y_2 \rangle/y_3] \multimap \ul{D}[\langle y_1 , y_2 \rangle/y_4]}}
{\hj {\Gamma, y_1 \!:\! A, y_2 \!:\! B} {z \!:\! \ul{C}[\langle y_1 , y_2 \rangle /y_3]} {K} {\ul{D}[\langle y_1 , y_2 \rangle /y_4]}}
\]
and $(4)$ by
\[
\mkrule
{\vj {\Gamma, x \!:\! \Sigma\, y_1 \!:\! A .\, B} x {\Sigma\, y_1 \!:\! A .\, B}}
{
\mkrule
{\vdash {\Gamma, x \!:\! \Sigma\, y_1 \!:\! A .\, B}}
{
\hspace{0.45cm}
\vdash \Gamma
\quad
\lj \Gamma {\Sigma\, y_1 \!:\! A .\, B
\quad
\mkrule
{x \not\in V\!ars(\Gamma)}}
{x \text{~is chosen fresh}}
}
}
\]
Derivations of the other typing rules listed above are constructed similarly.
\end{proof}


\begin{proposition}
The following $\beta$- and $\eta$-equations are derivable for the homomorphism term variant of:
\begin{itemize}
\item primitive recursion
\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\natrec {\ul{C}} {K_z} {y .\, K_s} {\zero}} {K_z} {\ul{C}}}
{
\lj {\Gamma} {\ul{C}} \quad \hj \Gamma {z \!:\! \ul{C}} {K_z} {\ul{C}} \quad \hj {\Gamma, y \!:\! \Nat} {z \!:\! \ul{C}} {K_s} {\ul{C}}
}
\]
\[
\mkrule
{
\begin{array}{c}
\Gamma \vertbar {z \!:\! \ul{C}} \vdash {\natrec {\ul{C}} {K_z} {y .\, K_s} {\suc V}} = 
{K_s[V/y][\natrec {\ul{C}} {K_z} {y .\, K_s} {V}/z]} : {\ul{C}}
\end{array}
}
{
\lj {\Gamma} {\ul{C}} \quad \vj \Gamma V \Nat
\quad
\hj \Gamma {z \!:\! \ul{C}} {K_z} {\ul{C}} \quad \hj {\Gamma, y \!:\! \Nat} {z \!:\! \ul{C}} {K_s} {\ul{C}}
}
\]
\item pattern-matching
\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z \!:\! \ul{C}[\langle V_1 , V_2 \rangle/y_3]} & \vdash & {\pmatch {\langle V_1 , V_2 \rangle} {(y_1 \!:\! A, y_2 \!:\! B)} {y_3.\, \ul{C} , y_4 .\, \ul{D}} K} 
\\[-1mm]
& = & K[V_1/y_1][V_2/y_2] : {\ul{D}[\langle V_1 , V_2 \rangle/y_4]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y_3 \!:\! \Sigma \, y_1 \!:\! A .\, B} {\ul{C}} \quad \lj {\Gamma, y_4 \!:\! \Sigma \, y_1 \!:\! A .\, B} {\ul{D}} \quad \vj \Gamma {V_1} {A}
\\[-1mm]
\vj \Gamma {V_2} {B[V_1/y_1]} \quad \hj {\Gamma, y_1 \!:\! A, y_2 \!:\! B} {z \!:\! \ul{C}[\langle y_1 , y_2 \rangle /y_3]} {K} {\ul{D}[\langle y_1 , y_2 \rangle /y_4]}
\end{array}
}
\]

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z \!:\! \ul{C}[V/y_3]} & \vdash & {\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {y_3.\, \ul{C} , y_4 .\, \ul{D}} K[\pair {y_1} {y_2}/y_5]} 
\\[-1mm]
& = & K[V/y_5] : {\ul{D}[V/y_4]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y_3 \!:\! \Sigma \, y_1 \!:\! A .\, B} {\ul{C}} \quad \lj {\Gamma, y_4 \!:\! \Sigma \, y_1 \!:\! A .\, B} {\ul{D}} 
\\[-1mm]
\vj \Gamma V {\Sigma \, y_1 \!:\! A .\, B} \quad \hj {\Gamma, y_5 \!:\! \Sigma\, y_1 \!:\! A .\, B} {z \!:\! \ul{C}[y_5 /y_3]} {K} {\ul{D}[y_5 /y_4]}
\end{array}
}
\]
\item empty case analysis
\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}[V/y_1]} {\absurd {y_1.\,\ul{C},y_2.\,\ul{D}} V} {K[V/y_3]} {\ul{D}[V/y_2]}}
{
\lj {\Gamma, y_1 \!:\! 0} \ul{C} \quad \lj {\Gamma, y_2 \!:\! 0} \ul{D}
\quad
\vj {\Gamma} V 0 \quad \hj {\Gamma, y_3 \!:\! 0} {z \!:\! \ul{C}[y_3/y_1]} K {\ul{D}[y_3/y_2]}
}
\]
\item binary case analysis
\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z \!:\! \ul{C}[\inl {A + B} V/y_1]} & \vdash & \case {(\inl {A + B} V)} {y_1.\, \ul{C},y_2.\, \ul{D}} {\inl {\!} {\!\!(y_3 \!:\! A)} \mapsto  K} {\\[-1mm] && \hspace{5.15cm} \inr {\!} {\!\!(y_4 \!:\! B)} \mapsto L}
\\
& = & K[V/y_3] : {\ul{D}[\inl {A + B} V/y_2]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y_1 \!:\! A + B} \ul{C} \quad \lj {\Gamma, y_2 \!:\! A + B} \ul{D} \quad \vj \Gamma V {A} 
\\[-1mm]
\hj {\Gamma, y_3 \!:\! A} {z \!:\! \ul{C}[\inl {A + B} y_3/y_1]} {K} {\ul{D}[\inl {A + B} y_3/y_2]} 
\\[-1mm]
\hj {\Gamma, y_4 \!:\! B} {z \!:\! \ul{C}[\inr {A + B} y_4/y_1]} {L} {\ul{D}[\inr {A + B} y_4/y_2]}
\end{array}
}
\]

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z \!:\! \ul{C}[\inr {A + B} V/y_1]} & \vdash & \case {(\inr {A + B} V)} {y_1.\, \ul{C},y_2.\, \ul{D}} {\inl {\!} {\!\!(y_3 \!:\! A)} \mapsto K} {\\[-1mm] && \hspace{5.15cm} \inr {\!} {\!\!(y_4 \!:\! B)} \mapsto L} 
\\
& = & L[V/y_4] : {\ul{D}[\inr {A + B} V/y_2]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y_1 \!:\! A + B} \ul{C} \quad \lj {\Gamma, y_2 \!:\! A + B} \ul{D} \quad \vj \Gamma V {B} 
\\[-1mm]
\hj {\Gamma, y_3 \!:\! A} {z \!:\! \ul{C}[\inl {A + B} y_3/y_1]} {K} {\ul{D}[\inl {A + B} y_3/y_2]} 
\\[-1mm]
\hj {\Gamma, y_4 \!:\! B} {z \!:\! \ul{C}[\inr {A + B} y_4/y_1]} {L} {\ul{D}[\inr {A + B} y_4/y_2]}
\end{array}
}
\]

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z \!:\! \ul{C}[V/y_1]} & \vdash & \mathtt{case~} V \mathtt{~of}_{y_1.\, \ul{C},y_2.\, \ul{D}} \mathtt{~} (\inl {\!} {\!\!(y_3 \!:\! A)} \mapsto K[\inl {A + B} y_3/y_5],
\\[-1mm]
&& \hspace{3.425cm} \inr {\!} {\!\!(y_4 \!:\! B)} \mapsto K[\inr {A + B} y_4/y_5]) 
\\
& = & K[V/y_4] : {\ul{D}[V/y_2]}
\end{array}
}
{
\begin{array}{c}
\lj {\Gamma, y_1 \!:\! A + B} \ul{C} \quad \lj {\Gamma, y_2 \!:\! A + B} \ul{D} 
\\[-1mm]
\vj \Gamma V {A + B} \quad \hj {\Gamma, y_5 \!:\! A + B} {z \!:\! \ul{C}[y_5/y_1]} {K} {\ul{D}[y_5/y_2]} 
\end{array}
}
\]
\pagebreak
\item elimination of propositional equality
\[
\mkrule
{
\begin{array}{c}
\hspace{-6.5cm} \Gamma \vertbar {z \!:\! \ul{C}[V/y_1][V/y_2][\refl A V/y_3]} \vdash 
\\[-1mm]
\hspace{3cm} {\pathind A {y_1.\, y_2.\, y_3.\, \ul{C} , y_4.\, y_5.\, y_6.\, \ul{D}} {y_7.\, K} {V} {V} {\refl A V}} 
\\
\hspace{-0.3cm} = K[V/y_7] : {\ul{D}[V/y_4][V/y_5][\refl A V/y_6]}
\end{array}
}
{
\begin{array}{c}
\lj \Gamma A
\quad
\vj \Gamma {V} A
\\[-1mm]
\lj {\Gamma, y_1 \!:\! A, y_2 \!:\! A, y_3 \!:\! y_1 =_A y_2} {\ul{C}} 
\quad 
\lj {\Gamma, y_4 \!:\! A, y_5 \!:\! A, y_6 \!:\! y_4 =_A y_5} {\ul{D}} 
\\[-1mm]
\hj {\Gamma, y_7 \!:\! A} {z \!:\! \ul{C}[y_7/y_1][y_7/y_2][\refl A y_7/y_3]} {K} {\ul{D}[y_7/y_4][y_7/y_5][\refl A y_7/y_6]}
\end{array}
}
\]
\end{itemize}
\end{proposition}

\begin{proof}
We prove this proposition by using the corresponding $\beta$- and $\eta$-equations for the value term variants of these elimination rules, together with the $\beta$-equation for homomorphic lambda abstraction and homomorphic function application. 

For example, the first $\beta$-equation for primitive recursion is proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \vertbar {z \!:\! \ul{C}} \,\vdash\,\, & \natrec {\ul{C}} {K_z} {y .\, K_s} {\zero}
\\
=\,\, & \big(\natrec {x_1.\,\ul{C} \,\multimap\, \ul{C}} {\lambda\, z \!:\! \ul{C} .\, K_z} {y.\, x_2.\, \lambda\, z \!:\! \ul{C} .\, K_s[x_2\, z/z]} {\zero}\big)\,\, z
\\
=\,\, & (\lambda\, z \!:\! \ul{C} .\, K_z)\,\, z
\\
=\,\, & K_z : \ul{C}
\end{align*}
\end{fleqn}
and the second $\beta$-equation as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \vertbar {z \!:\! \ul{C}} \,\vdash\,\, & \natrec {\ul{C}} {K_z} {y .\, K_s} {\suc V , z_3}
\\
=\,\, & \big(\natrec {x_1.\,\ul{C} \,\multimap\, \ul{C}} {\lambda\, z \!:\! \ul{C} .\, K_z} {y.\, x_2.\, \lambda\, z \!:\! \ul{C} .\, K_s[x_2\, z/z]} {\suc V}\big)\,\, z
\\
=\,\, & \big((\lambda\, z \!:\! \ul{C} .\, K_s[x_2\, z/z])[V/y]
\\[-2mm]
& \hspace{0.3cm} [\natrec {x_1.\,\ul{C} \,\multimap\, \ul{C}} {\lambda\, z \!:\! \ul{C} .\, K_z} {y.\, x_2.\, \lambda\, z \!:\! \ul{C} .\, K_s[x_2\, z/z]} {V}/x_2]\big)\,\, z
\\
=\,\, & K_s[x_2\, z/z][V/y][\natrec {x_1.\,\ul{C} \,\multimap\, \ul{C}} {\lambda\, z \!:\! \ul{C} .\, K_z} {y.\, x_2.\, \lambda\, z \!:\! \ul{C} .\, K_s[x_2\, z/z]} {V}/x_2]
\\
=\,\, & K_s[V/y][x_2\, z/z][\natrec {x_1.\,\ul{C} \,\multimap\, \ul{C}} {\lambda\, z \!:\! \ul{C} .\, K_z} {y.\, x_2.\, \lambda\, z \!:\! \ul{C} .\, K_s[x_2\, z/z]} {V}/x_2]
\\
=\,\, & K_s[V/y][\natrec {\ul{C}} {K_z} {y .\, K_s} {V}/z] : \ul{C}
\end{align*}
\end{fleqn}

As another example, the $\eta$-equation for pattern-matching is proved as follows:
\begin{fleqn}[0.2cm]
\begin{align*}
\Gamma \vertbar {z \!:\! \ul{C}[V/y_3]} \,\vdash\,\, & {\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {y_3.\, \ul{C} , y_4 .\, \ul{D}} (K[\pair {y_1} {y_2}/y_5])}
\\
=\,\, & \big(\pmatch V {(y_1 \!:\! A, y_2 \!:\! B)} {x.\, \ul{C}[x/y_3] \,\multimap\, \ul{D}[x/y_4]} {
\\ 
& \hspace{5cm} (\lambda\, z \!:\! \ul{C}[\langle y_1 , y_2 \rangle/y_3] .\, K[\pair {y_1} {y_2}/y_5])\big) \,\, z}
\\
=\,\, & (\lambda\, z \!:\! \ul{C}[V/y_3] .\, K[V/y_5])\,\, z
\\
=\,\, & K[V/y_5] : \ul{D}[V/y_4]
\end{align*}
\end{fleqn}
The other $\beta$- and $\eta$-equations listed above are proved similarly.
\end{proof}


\section{Derivable equations}
\label{sect:derivableequations}

We conclude this chapter by presenting some useful derivable equations.

We begin with equations that are familiar from other (monadic) effectful languages, such as Moggi's computational $\lambda$-calculus~\cite{Moggi:ComputationalLambdaCalculus}. Specifically, we show how to derive the right unit and associativity equations for for sequential composition. Note that the left unit equation is already included in the definition of eMLTT's equational theory.

\begin{proposition}
\label{prop:monadicequations}
The following right unit and associativity equations are derivable for sequential composition:
\[
\mkrule
{\ceq \Gamma {\doto {M} {x \!:\! A} {} {\return x}} {M} {FA}}
{\cj \Gamma M {FA} \quad x \not\in V\!ars(\Gamma)}
\]

\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\doto {K} {x \!:\! A} {} {\return x}} {K} {FA}}
{\hj \Gamma {z \!:\! \ul{C}} K {FA} \quad x \not\in V\!ars(\Gamma)}
\]

\[
\mkrule
{\ceq \Gamma {\doto {M_1} {x \!:\! A} {} {(\doto {M_2} {y \!:\! B} {} {M_3})}} {\doto {(\doto {M_1} {x \!:\! A} {} {M_2})} {y \!:\! B} {} {M_3}} {\ul{C}}}
{\cj \Gamma {M_1} {FA} \quad \cj {\Gamma, x \!:\! A} {M_2} {FB} \quad \cj {\Gamma, y \!:\! B} {M_3} {\ul{C}} \quad \lj \Gamma {\ul{C}} \quad x \neq y}
\]

\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\doto {K} {x \!:\! A} {} {(\doto {M} {y \!:\! B} {} {N})}} {\doto {(\doto {K} {x \!:\! A} {} {M})} {y \!:\! B} {} {N}} {\ul{D}}}
{\hj \Gamma {z \!:\! \ul{C}} {K} {FA} \quad \cj {\Gamma, x \!:\! A} {M} {FB} \quad \cj {\Gamma, y \!:\! B} {N} {\ul{D}} \quad \lj \Gamma {\ul{D}} \quad x \neq y}
\]
\end{proposition}

\begin{proof}
All four equations are proved using the $\beta$- and $\eta$-equations for sequential composition.
In particular, the two right unit equations are proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \,\vdash\,\, & \doto {M} {x \!:\! A} {} {\return x}
&
\Gamma \vertbar {z \!:\! \ul{C}} \,\vdash\,\, & \doto {K} {x \!:\! A} {} {\return x}
\\
=\,\, & \doto {M} {x \!:\! A} {} {z[\return x]/z}
&
=\,\, & \doto {K} {x \!:\! A} {} {z[\return x]/z}
\\
=\,\, & z[M/z]
&
=\,\, & z[K/z]
\\
=\,\, & M : FA
&
=\,\, & K : FA
\end{align*}
\end{fleqn}
the associativity equation for computation terms is proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \,\vdash\,\, & \doto {M_1} {x \!:\! A} {} {(\doto {M_2} {y \!:\! B} {} {M_3})}
\\
=\,\, & \doto {M_1} {x \!:\! A} {} {\big(\doto {(\doto {\return x} {x' \!:\! A} {} {M_2[x'/x]})} {y \!:\! B} {} {M_3}\big)}
\\
=\,\, & \doto {M_1} {x \!:\! A} {} {\big(\doto {(\doto {z} {x' \!:\! A} {} {M_2[x'/x]})} {y \!:\! B} {} {M_3}\big)[\return x/z]}
\\
=\,\, & \doto {(\doto {M_1} {x' \!:\! A} {} {M_2[x'/x]})} {y \!:\! B} {} {M_3}
\\
=\,\, & \doto {(\doto {M_1} {x \!:\! A} {} {M_2})} {y \!:\! B} {} {M_3} : \ul{C}
\end{align*}
\end{fleqn}
and the associativity equation for homomorphism terms is proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \vertbar {z \!:\! \ul{C}} \,\vdash\,\, & \doto {K} {x \!:\! A} {} {(\doto {M} {y \!:\! B} {} {N})}
\\
=\,\, & \doto {K} {x \!:\! A} {} {\big(\doto {(\doto {\return x} {x' \!:\! A} {} {M[x'/x]})} {y \!:\! B} {} {N}\big)}
\\
=\,\, & \doto {K} {x \!:\! A} {} {\big(\doto {(\doto {z} {x' \!:\! A} {} {M[x'/x]})} {y \!:\! B} {} {N}\big)[\return x/z]}
\\
=\,\, & \doto {(\doto {K} {x' \!:\! A} {} {M[x'/x]})} {y \!:\! B} {} {N}
\\
=\,\, & \doto {(\doto {K} {x \!:\! A} {} {M})} {y \!:\! B} {} {N} : \ul{D}
\end{align*}
\end{fleqn}
\end{proof}

Next, we observe that we can also derive analogous right unit and associativity equations for computational pattern-matching.

\begin{proposition}
\label{prop:comppatternmatchingequations}
The following right unit and associativity equations are derivable for computational pattern-matching:
\[
\mkrule
{\ceq \Gamma {\doto {M} {(x \!:\! A , z \!:\! \ul{C})} {} {\pair x z}} {M} {\Sigma\, x \!:\! A .\, \ul{C}}}
{\cj \Gamma M {\Sigma\, x \!:\! A .\, \ul{C}}}
\vspace{0.25cm}
\]

\[
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto {K} {(x \!:\! A , z_2 \!:\! \ul{D})} {} {\pair x {z_2}}} {K} {\Sigma\, x \!:\! A .\, \ul{D}}}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma\, x \!:\! A .\, \ul{D}}}
\vspace{0.25cm}
\]

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\doto {M} {(x \!:\! A , z_1 \!:\! \ul{C}_1)} {} {(\doto {K} {(y \!:\! B , z_2 \!:\! \ul{C}_2)} {} {L})}} 
\\[-1mm]
& = & {\doto {(\doto {M} {(x \!:\! A , z_1 \!:\! \ul{C}_1)} {} {K})} {(y \!:\! B , z_2 \!:\! \ul{C}_2)} {} {L}} : {\ul{D}}
\end{array}
}
{
\cj \Gamma {M} {\Sigma\, x \!:\! A .\, \ul{C}_1} \quad
\hj {\Gamma, x \!:\! A} {z_1 \!:\! \ul{C}_1} {K} {\Sigma\, y \!:\! B .\, \ul{C}_2} 
\quad
\hj {\Gamma, y \!:\! B} {z_2 \!:\! \ul{C}_2} {L} {\ul{D}}
\quad
\lj \Gamma {\ul{D}}
}
\]

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z_1 \!:\! \ul{C}} & \vdash & {\doto {K_1} {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {(\doto {K_2} {(y \!:\! B , z_3 \!:\! \ul{D}_2)} {} {K_3})}} 
\\[-1mm]
& = & {\doto {(\doto {K_1} {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {K_2})} {(y \!:\! B , z_3 \!:\! \ul{D}_2)} {} {K_3}} : {\ul{D}_3}
\end{array}
}
{
\begin{array}{c}
\hj \Gamma {z_1 \!:\! \ul{C}} {K_1} {\Sigma\, x \!:\! A .\, \ul{D}_1} \quad
\hj {\Gamma, x \!:\! A} {z_2 \!:\! \ul{D}_1} {K_2} {\Sigma\, y \!:\! B .\, \ul{D}_2} 
\\[-1mm]
\hj {\Gamma, y \!:\! B} {z_3 \!:\! \ul{D}_2} {K_3} {\ul{D}_3}
\quad
\lj \Gamma {\ul{D}_3}
\end{array}
}
\]
\end{proposition}

\begin{proof}
These four equations are proved similarly to the equations given in Proposition~\ref{prop:monadicequations}, using the $\beta$- and $\eta$-equations for computational pattern-matching.
\end{proof}

Next, we can show that sequential composition commutes with other computational term formers from the left.

\begin{proposition}
\label{prop:seqcompdistributivity}
Sequential composition commutes with computational pairing, \linebreak computational pattern-matching, lambda abstraction, computational function appli-\linebreak 

\pagebreak
\noindent
cation, and homomorphic function application from the left:
\[
\mkrule
{\ceq \Gamma {\doto {M} {x \!:\! A} {} {\pair V N}} {\pair V {\doto M {x \!:\! A} {} N}} {\Sigma \, y \!:\! B .\, \ul{C}}}
{\cj \Gamma M {FA} \quad \vj \Gamma V B \quad \cj {\Gamma, x \!:\! A} N {\ul{C}[V/y]} \quad \lj {\Gamma, y \!:\! B} \ul{C}}
\]

\vspace{0.1cm}

\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\doto {K} {x \!:\! A} {} {\pair V M}} {\pair V {\doto K {x \!:\! A} {} M}} {\Sigma \, y \!:\! B .\, \ul{D}}}
{\hj \Gamma {z \!:\! \ul{C}} K {FA} \quad \vj \Gamma V B \quad \cj {\Gamma, x \!:\! A} M {\ul{D}[V/y]} \quad \lj {\Gamma, y \!:\! B} \ul{D}}
\]

\vspace{0.1cm}

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma & \vdash & {\doto M {x \!:\! A} {} {(\doto N {(y \!:\! B , z \!:\! \ul{C})} {} {K})}} 
\\[-1mm]
& = & {\doto {(\doto M {x \!:\! A} {} N)} {(y \!:\! B , z \!:\! \ul{C})} {} {K}} : {\ul{D}}
\end{array}
}
{\cj \Gamma M {FA} \quad \cj {\Gamma, x \!:\! A} N {\Sigma\, y \!:\! B .\, \ul{C}} \quad \lj {\Gamma, y \!:\! B} {\ul{C}} \quad \hj {\Gamma, y \!:\! B} {z \!:\! \ul{C}} K {\ul{D}} \quad \lj \Gamma \ul{D}}
\]

\vspace{0.1cm}

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z_1 \!:\! \ul{C}} & \vdash & {\doto K {x \!:\! A} {} {(\doto M {(y \!:\! B , z_2 \!:\! \ul{D}_1)} {} {L})}} 
\\[-2mm]
& = & {\doto {(\doto K {x \!:\! A} {} M)} {(y \!:\! B , z_2 \!:\! \ul{D}_1)} {} {L}} : {\ul{D}_2}
\end{array}
}
{
\begin{array}{c}
\hj \Gamma {z_1 \!:\! \ul{C}} K {FA} \quad \cj {\Gamma, x \!:\! A} M {\Sigma\, y \!:\! B .\, \ul{D}_1}
\\[-1mm]
\lj {\Gamma, y \!:\! B} {\ul{D}_1} \quad \hj {\Gamma, y \!:\! B} {z_2 \!:\! \ul{C}} L {\ul{D}_2} \quad \lj \Gamma \ul{D}_2
\end{array}
}
\]

\vspace{0.1cm}

\[
\mkrule
{\ceq \Gamma {\doto M {x \!:\! A} {} {(\lambda\, y \!:\! B .\, N)}} {\lambda \, y \!:\! B .\, (\doto M {x \!:\! A} {} N)} {\Pi\, y \!:\! B .\, \ul{C}}}
{\cj \Gamma M {FA} \quad \cj {\Gamma, x \!:\! A, y \!:\! B} N {\ul{C}} \quad \lj \Gamma B \quad \lj {\Gamma, y \!:\! B} \ul{C}}
\]

\vspace{0.1cm}

\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\doto K {x \!:\! A} {} {(\lambda\, y \!:\! B .\, M)}} {\lambda \, y \!:\! B .\, (\doto K {x \!:\! A} {} M)} {\Pi\, y \!:\! B .\, \ul{D}}}
{\hj \Gamma {z \!:\! \ul{C}} K {FA} \quad \cj {\Gamma, x \!:\! A, y \!:\! B} M {\ul{D}} \quad \lj \Gamma B \quad \lj {\Gamma, y \!:\! B} \ul{D}}
\]

\vspace{0.1cm}

\[
\mkrule
{\ceq \Gamma {\doto M {x \!:\! A} {} {N\, V}} {(\doto M {x \!:\! A} {} N)\, V} {\ul{C}[V/x]}}
{\cj \Gamma M {FA} \quad \cj {\Gamma, x \!:\! A} N {\Pi\, y \!:\! B .\, \ul{C}} \quad \vj \Gamma V B \quad \lj {\Gamma, y \!:\! B} {\ul{C}}}
\]

\vspace{0.1cm}

\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\doto K {x \!:\! A} {} {M\, V}} {(\doto K {x \!:\! A} {} M)\, V} {\ul{D}[V/x]}}
{\hj \Gamma {z \!:\! \ul{C}} K {FA} \quad \cj {\Gamma, x \!:\! A} M {\Pi\, y \!:\! B .\, \ul{D}} \quad \vj \Gamma V B \quad \lj {\Gamma, y \!:\! B} {\ul{D}}}
\]

\vspace{0.1cm}

\[
\mkrule
{\ceq \Gamma {\doto M {x \!:\! A} {} {V\, N}} {V\, (\doto M {x \!:\! A} {} {N})} {\ul{D}}}
{\cj \Gamma M {FA} \quad \vj \Gamma {V} {\ul{C} \multimap \ul{D}} \quad \cj {\Gamma, x \!:\! A} N {\ul{C}}}
\]

\vspace{0.1cm}

\[
\mkrule
{\heq \Gamma {z \!:\! \ul{C}} {\doto K {x \!:\! A} {} {V\, M}} {V\, (\doto K {x \!:\! A} {} {M})} {\ul{D}_2}}
{\hj \Gamma {z \!:\! \ul{C}} K {FA} \quad \vj \Gamma {V} {\ul{D}_1 \multimap \ul{D}_2} \quad \cj {\Gamma, x \!:\! A} M {\ul{D}_1}}
\]
\end{proposition}

\begin{proof}
All these equations are proved using the $\beta$- and $\eta$-equations for sequential composition, following a similar pattern to the proofs of Propositions~\ref{prop:monadicequations} and~\ref{prop:comppatternmatchingequations}. 

\pagebreak

For example, commutativity with homomorphic function application is proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \vertbar {z \!:\! \ul{C}} \,\vdash\,\, & \doto K {x \!:\! A} {} {V\, M}
\\
=\,\, & \doto K {x \!:\! A} {} {V\, (\doto {\return x} {y \!:\! A} {} {M[y/x]})}
\\
=\,\, & \doto K {x \!:\! A} {} {V\, (\doto {z} {y \!:\! A} {} {M[y/x]})[\return x/z]}
\\
=\,\, & \doto K {x \!:\! A} {} {\big(V\, (\doto {z} {y \!:\! A} {} {M[y/x]})\big)[\return x/z]}
\\
=\,\, & V\, (\doto K {y \!:\! A} {} {M[y/x]})
\\
=\,\, & V\, (\doto K {x \!:\! A} {} {M}) : \ul{D}_2
\end{align*}
\end{fleqn}
\end{proof}

Analogously to sequential composition, computational pattern-matching also commutes with other computational term-formers from the left, as shown next.

\begin{proposition}
\label{prop:comppatternmatchingdistributivity}
Computational pattern-matching commutes with sequential composition, computational pairing, computational lambda abstraction, computational function application, and homomorphic function application from the left:
\vspace{0.2cm}
\[
\mkrule
{\ceq \Gamma {\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {(\doto K {y \!:\! B} {} {N})}} {\doto {(\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {K})} {y \!:\! B} {} {N}} {\ul{D}}}
{\cj \Gamma M {\Sigma\, x \!:\! A .\, \ul{C}} \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} {K} {FB} \quad \cj {\Gamma, y \!:\! B} N {\ul{D}} \quad \lj \Gamma \ul{D}}
\]

\vspace{0.1cm}

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z_1 \!:\! \ul{C}} & \vdash & {\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {(\doto L {y \!:\! B} {} {M})}} 
\\[-1mm]
& = & {\doto {(\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {L})} {y \!:\! B} {} {M}} : {\ul{D}_2}
\end{array}
}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma\, x \!:\! A .\, \ul{D}_1} \quad \hj {\Gamma, x \!:\! A} {z_2 \!:\! \ul{D}_1} {L} {FB} \quad \cj {\Gamma, y \!:\! B} M {\ul{D}_2} \quad \lj \Gamma \ul{D}_2} 
\]

\vspace{0.1cm}

\[
\mkrule
{\ceq \Gamma {\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {\pair V K}} {\pair V {\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {K}}} {\Sigma\, y \!:\! B .\, \ul{D}}}
{\cj \Gamma M {\Sigma\, x \!:\! A .\, \ul{C}} \quad \vj \Gamma V B \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} {K} {\ul{D}[V/y]} \quad \lj {\Gamma, y \!:\! B} \ul{D}}
\]

\vspace{0.1cm}

\[
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {\pair V L}} {\pair V {\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {L}}} {\Sigma\, y \!:\! B .\, \ul{D}_2}}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma\, x \!:\! A .\, \ul{D}_1} \quad \vj \Gamma V B \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{D}_1} {L} {\ul{D}_2[V/y]} \quad \lj {\Gamma, y \!:\! B} \ul{D}_2}
\]

\vspace{0.1cm}

\[
\mkrule
{\ceq \Gamma {\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {(\lambda\, y \!:\! B .\, K)}} {\lambda\, y \!:\! B .\, (\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {K})} {\Pi\, y \!:\! B .\, \ul{D}}}
{\cj \Gamma M {\Sigma\, x \!:\! A .\, \ul{C}} \quad \hj {\Gamma, x \!:\! A, y \!:\! B} {z \!:\! \ul{C}} {K} {\ul{D}} \quad \lj {\Gamma, y \!:\! B} \ul{D}}
\]

\vspace{0.1cm}

\[
\mkrule
{
\begin{array}{c@{~} c@{~} l}
\Gamma \vertbar {z_1 \!:\! \ul{C}} & \vdash & {\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {(\lambda\, y \!:\! B .\, L)}} 
\\[-1mm]
& = & {\lambda\, y \!:\! B .\, (\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {L})} : {\Pi\, y \!:\! B .\, \ul{D}_2}
\end{array}
}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma\, x \!:\! A .\, \ul{D}_1} \quad \hj {\Gamma, x \!:\! A, y \!:\! B} {z_2 \!:\! \ul{D}_1} {L} {\ul{D}_2} \quad \lj {\Gamma, y \!:\! B} \ul{D}_2}
\]

\vspace{0.1cm}

\[
\mkrule
{\ceq \Gamma {\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {K\,\, V}} {(\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {K})\,\, V} {\ul{D}[V/y]}}
{\cj \Gamma M {\Sigma\, x \!:\! A .\, \ul{C}} \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} K {\Pi\, y \!:\! B .\, \ul{D}} \quad \vj \Gamma V B \quad \lj {\Gamma, y \!:\! B} \ul{D}}
\]

\vspace{0.1cm}

\[
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {L\,\, V}} {(\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {L})\,\, V} {\ul{D}_2[V/y]}}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma\, x \!:\! A .\, \ul{D}_1} \quad \hj {\Gamma, x \!:\! A} {z_2 \!:\! \ul{D}_1} L {\Pi\, y \!:\! B .\, \ul{D}_2} \quad \vj \Gamma V B \quad \lj {\Gamma, y \!:\! B} \ul{D}_2}
\]

\vspace{0.1cm}

\[
\mkrule
{\ceq \Gamma {\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {V\, K}} {V\, (\doto M {(x \!:\! A , z \!:\! \ul{C})} {} {K})} {\ul{D}_2}}
{\cj \Gamma M {\Sigma\, x \!:\! A .\, \ul{C}} \quad \vj \Gamma V {\ul{D}_1 \multimap \ul{D}_2} \quad \hj {\Gamma, x \!:\! A} {z \!:\! \ul{C}} K {\ul{D}_1}}
\]

\vspace{0.1cm}

\[
\mkrule
{\heq \Gamma {z_1 \!:\! \ul{C}} {\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {V\, L}} {V\, (\doto K {(x \!:\! A , z_2 \!:\! \ul{D}_1)} {} {L})} {\ul{D}_3}}
{\hj \Gamma {z_1 \!:\! \ul{C}} K {\Sigma\, x \!:\! A .\, \ul{D}_1} \quad \vj \Gamma V {\ul{D}_2 \multimap \ul{D}_3} \quad \hj {\Gamma, x \!:\! A} {z_2 \!:\! \ul{D}_1} L {\ul{D}_2}}
\]
\end{proposition}

\begin{proof}
All these equations are proved by using the $\beta$- and $\eta$-equations for computational pattern-matching, following a similar pattern to the proof of Proposition~\ref{prop:seqcompdistributivity}. 

For example, commutativity with sequential composition is proved as follows:
\begin{fleqn}[0.2cm]
\begin{align*}
\Gamma \,\vdash\,\, & \doto M {(x \!:\! A,z \!:\! \ul{C})} {} {(\doto K {y \!:\! B} {} {N})}
\\
=\,\, & \doto M {(x \!:\! A,z \!:\! \ul{C})} {} {\big(\doto {\big(\doto {\langle x , z \rangle} {(x' \!:\! A, z' \!:\! \ul{C}[x'/x])} {} {K[x'/x][z'/z]}\big)} {y \!:\! B} {} {N}\big)}
\\
=\,\, & \doto M {(x \!:\! A,z \!:\! \ul{C})} {} {\big(\\[-1mm] & \hspace{2.45cm} \doto {\big(\doto {z''} {(x' \!:\! A, z' \!:\! \ul{C}[x'/x])} {} {K[x'/x][z'/z]}\big)[\langle x , z \rangle/z'']} {y \!:\! B} {} {N}\big)}
\\
=\,\, & \doto M {(x \!:\! A,z \!:\! \ul{C})} {} {\big(\\[-1mm] & \hspace{2.45cm} \doto {\big(\doto {z''} {(x' \!:\! A, z' \!:\! \ul{C}[x'/x])} {} {K[x'/x][z'/z]}\big)} {y \!:\! B} {} {N}\big)[\langle x , z \rangle/z'']}
\\
=\,\, & \doto {\big(\doto {M} {(x' \!:\! A, z' \!:\! \ul{C}[x'/x])} {} {K[x'/x][z'/z]}\big)} {y \!:\! B} {} {N}
\\
=\,\, & \doto {(\doto {M} {(x \!:\! A, z \!:\! \ul{C})} {} {K})} {y \!:\! B} {} {N} : \ul{D}
\end{align*}
\end{fleqn}

As another example, commutativity with homomorphic function application is proved as follows:
\begin{fleqn}[0.3cm]
\begin{align*}
\Gamma \,\vdash\,\, & \doto M {(x \!:\! A , z \!:\! \ul{C})} {} {V\, K}
\\
=\,\, & \doto M {(x \!:\! A , z \!:\! \ul{C})} {} {V\, \big(\doto {\langle x , z \rangle} {(y \!:\! A, z' \!:\! \ul{C}[z'/z])} {} {K[y/x][z'/z]}\big)}
\\
=\,\, & \doto M {(x \!:\! A , z \!:\! \ul{C})} {} {\big(V\, \big(\doto {z''} {(y \!:\! A, z' \!:\! \ul{C}[z'/z])} {} {K[y/x][z'/z]}\big)\big)[\langle x , z \rangle/z'']}
\\
=\,\, & V\, \big(\doto {M} {(y \!:\! A, z' \!:\! \ul{C}[z'/z])} {} {K[y/x][z'/z]}\big)
\\
=\,\, & V\, (\doto {M} {(x \!:\! A, z \!:\! \ul{C})} {} {K}) : \ul{D}_2
\end{align*}
\end{fleqn}
\end{proof}






















